<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[互测题总结]]></title>
      <url>%2F2018%2Fprobelm-select%2F</url>
      <content type="text"><![CDATA[String 称一个仅由a, b, c组成的字符串 $S$ 是平衡的当且仅当对于 $S$ 的任意一个连续子串 $T$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[拓展埃氏筛法小结]]></title>
      <url>%2F2018%2Fex-eratos-sieve%2F</url>
      <content type="text"><![CDATA[学完洲阁筛之后忘得差不多了, 不过现在已经可以将洲阁筛扔进垃圾桶了… Description求: S(N) = \sum_{i=1}^{N} F(i)其中 $F$ 满足在 $i$ 是质数幂的情况下比较好算并且是一个积性函数. Conversion首先将所有的 $i$ 按照最大质因子的次数是否大于一分为两类计算答案. 对于第一类的数, 我们将最大质因子除去, 剩下的部分一定只包含不超过 $\sqrt{N}$ 的质因子, 于是可以暴搜所有剩下的部分, 同时这个过程中一定会遍历所有第二类的数. 接下来只需计算 $s(i)$ 表示 $[1, i]$ 中所有质数的 $F$ 的和. 因为 $p \le \sqrt{N}$, 所以有用的状态只有 $O(\sqrt{N})$ 个.枚举 $[1, \sqrt{N}]$ 中的所有质数 $p$, 考虑每次筛去最小质因子为 $p$ 的数的贡献.那么对于每个 $p$ , 都会使得一个满足 $i \ge p^2$ 的 $s(i)$ 减去 $s(\lfloor \frac{i}{p} \rfloor) - s(p-1)$. 这样子的复杂度大约为 $O\left (\frac{N^{\frac{3}{4}}}{\log{N}}\right )$ Code以 $\varphi$ 函数为例 (实际效率似乎不输杜教筛?). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566namespace Sieve &#123; ll n; ll s0[N + 5], S0[N + 5]; ll s1[N + 5], S1[N + 5]; int m, prime[N + 5], pcnt; inline int calc(ll res, int lst, ll mul) &#123; ll temp = (res &gt; m ? S1[n / res] : s1[res]) - s1[prime[lst]]; ll ans = temp * mul % mo; for(int i = lst + 1; i &lt;= pcnt; ++i) &#123; int p = prime[i]; if((ll) p * p &gt; res) break; for(ll j = p, nmul = mul * (p-1) % mo; res &gt;= j * p; j *= p) &#123; ans = (ans + calc(res / j, i, nmul)) % mo; nmul = nmul * p % mo; ans = (ans + nmul) % mo; &#125; &#125; return ans; &#125; int solve(ll _n) &#123; n = _n; if(n &lt;= 1) return n; pcnt = 0; m = (int) sqrt(n + 0.5); for(int i = 1; i &lt;= m; ++i) &#123; s0[i] = i - 1; s1[i] = (ll) (2 + i) * (i - 1) / 2 % mo; ll t = (n / i) % mo; S0[i] = t - 1; S1[i] = (ll) (2 + t) * (t - 1) / 2 % mo; &#125; for(int i = 2; i &lt;= m; ++i) &#123; if(s0[i] == s0[i-1]) continue; prime[++ pcnt] = i; const ll t0 = s0[i-1], t1 = s1[i-1], p = (ll) i * i; const ll lim = std::min((ll) m, n / p), x = m / i, y = n / i; for(int j = 1; j &lt;= x; ++j) &#123; S0[j] = (S0[j] - (S0[j * i] - t0)) % mo; S1[j] = (S1[j] - (S1[j * i] - t1) * i) % mo; &#125; for(int j = x+1; j &lt;= lim; ++j) &#123; S0[j] = (S0[j] - (s0[y / j] - t0)) % mo; S1[j] = (S1[j] - (s1[y / j] - t1) * i) % mo; &#125; for(int j = m; j &gt;= p; --j) &#123; s0[j] = (s0[j] - (s0[j / i] - t0)) % mo; s1[j] = (s1[j] - (s1[j / i] - t1) * i) % mo; &#125; &#125; for(int i = 1; i &lt;= m; ++i) &#123; s1[i] = (s1[i] - s0[i] + mo) % mo; S1[i] = (S1[i] - S0[i] + mo) % mo; &#125; return (1 + calc(n, 0, 1)) % mo; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Calc]]></title>
      <url>%2F2018%2Ftsinsen-calc%2F</url>
      <content type="text"><![CDATA[Description 给定 $N$, 求有多少组 $a$, $b$ 满足:$1 \le a &lt; b \le N$$a + b \mid a \times b$ $N \le 2 ^ {31} - 1$ Analysis考虑转化条件二:令 $d = \gcd(a, b),\,\, a = a’d,\,\, b = b’d$. 那么条件二等价于: a'd + b'd \mid a'b'd^2 \Rightarrow a' + b' \mid a'b'd \Rightarrow a' + b' \mid d令 $d = t(a’ + b’)$, 则: b = b'd = b'(a' + b')t考虑枚举 $p = b’,\,\, q = (a’ + b’)$, 计算 $t$ 的数量: Ans = \sum_{p=2}^{\sqrt{N}}\sum_{q=p+1}^{2p-1} \[\gcd(p, q) = 1\] \left\lfloor \frac{N}{pq} \right\rfloorAlgorithm 1定义 $L_i$ 为 $i$ 的质因子个数. 首先枚举 $p$, 考虑有哪些 $q$ 能对答案产生贡献, 每次用 $O(L_p)$ 的时间判断 $p, q$ 是否互质. 复杂度为 $O(\sqrt{N} \sum_{i=2}^{\sqrt{N}} L_i) = O(N \log\log \sqrt{N})$ Algorithm 2枚举完 $p$ 之后, $T = \lfloor \frac{N}{p} \rfloor$ 的值就确定了. 只需要考虑 $\lfloor \frac{T}{q} \rfloor$ 的值即可, 考虑对这样的 $q$ 进行分块, 每一块内部利用 $2^{L_p}$ 的容斥计算与 $p$ 互质的 $q$ 的个数. 复杂度近似为 $O(\sqrt{N} \sum_{i=2}^{\sqrt{N}} 2^{L_i})$ Complexity Analysis分析实际运行的情况, 发现理论复杂度更高的算法二表现优于算法一, 原因是 $\lfloor \frac{T}{q} \rfloor$ 的取值很少. 考虑综合两种算法的长处, 在 $q$ 比较小的时候, $\lfloor \frac{T}{q} \rfloor$ 的取值比较多, 我们使用算法一, $q$ 比较大的时候使用算法二. 假设这个分界点为 $k$, 复杂度: f(k) = (k - p) L + (\left\lfloor \frac{T}{k} \right\rfloor + \left\lfloor \frac{T}{2p} \right\rfloor)2^L只考虑其中与 $k$ 相关的部分: f(k) = kL + \frac{T2^L}{k}根据基本不等式, 使得 $f$ 最优的 $k = \sqrt{\frac{T2^L}{L}}$, 此时 $f(k) = 2\sqrt{T2^LL}$. 然后算一下复杂度, 发现在 $N = 2^{31}-1$ 时, 复杂度大约为 $8 \times 10 ^ 7$.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记NOI2018]]></title>
      <url>%2F2018%2Fnoi2018%2F</url>
      <content type="text"><![CDATA[折腾了好久终于把博客修好了, 来填一些坑. Day -1上午在家无所事事, 收了下行李, 下午就到洋湖报到去了, 然后听说笔试时间调整到了上午, 感觉有点慌整个晚上都在背笔试. Day 0上午考笔试, 比预料中的简单很多, 没有什么快捷键之类的坑题也没有挂分, 试机就打了一个最简单的配置就跑了. 下午找了一间教室自习, 不知道干什么, 晚上懒得复习什么早早地睡了, 奇怪的是居然丝毫不紧张. Day 1第一试, 看了看题, 觉得题意都挺好理解的, 难度也基本按照题目顺序. 就直接开始写T1了, 写完 $\log^2$ 过了大样例直接丢到一边了, 然后看T2, 推了一个看起来有理有据的结论, 但不是很会算答案搞了很久大样例四个全错, 想了一下随便打了个特判过了其中两个, 又改了一下特判才在考试一半时间的时候过了大样例. 期间去上了一个厕所, 用掉20min… 看T3惊喜地发现68分特别傻逼, 飞快地码完过了大样例还有一个半小时, 正准备回去继续做T2最后20分的时候发现T1可能跑不过, 卡了很久的常, 期间竟然检查出好多致命的错误, 然后心里特别虚地不停检查, T2也没有继续想了. 好在最后并没有挂分. Day 1.5鸽了社会活动, 在自习室搞了一天颓. 直接打出了防沉迷警告… Day 2看完题目一直在想哪道题最简单, 然后T1补充了一个条件… 用了两个小时都没有从T1的倒数第二步推出最后一步, 想想当时可能真的受到了降智打击, 还自信地觉得T2比较可做, 码了很久发现是假算法, 感觉很慌滚去写T3暴力, 回来想先写T2的45分又不想放弃T1, 最后连T2的45分都没拿到… 感觉心态真的崩的厉害, 虽然最后查分发现意外的多了5分(大雾). 总结好像从去年NOIP以来, 身上一直有某种二试Debuff存在, 可能经常性的因为第一试考得不错, 而对多数情况下更难的二试心存轻视, 也没能调整好自己的心态吧. 不管怎样, 接下来的OI生涯, 要更加珍惜!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[平面树计数]]></title>
      <url>%2F2017%2Fcount-plane-tree%2F</url>
      <content type="text"><![CDATA[不常见的经典问题, 顺便总结一下Burnside引理吧. 问题描述 给定 $N$, 求 $N$ 个点的本质不同的平面树的数量.两棵平面树是等价的当且仅当其中一棵能够移动点的位置与另一棵重合, 且过程中仍然是一棵平面树. 做法考虑模型转化(计算 $N+1$ 个点的答案):取单位圆, 等距地取 $2N$ 个点, 然后将这些点两两配对连边, 满足所有连边不相交.发现它的对偶图恰好是一棵平面树, 像这样: 那么就只需要考虑本质不同的这样的配对的数量即可.两个圆是等价的当且仅当一个圆可以通过旋转一定的角度与另一个圆重合.而在这个圆上共有 $2N$ 个点, 就意味着有 $2N$ 个置换, 构成一个置换群. 置换群下的计数可以用到 Burnside引理 : N(G, C) = \frac{1}{|G|} { \sum_{f \in G} c(f) } 则转化为求置换下的不动点的数量: 不存在置换的情况下, 答案为 $C_N$, $\mathrm{Catalan}$ 数的第 $N$ 项.即将相互匹配的位置看作左右括号, 则所有合法的括号序列都对应一个满足条件的圆. $N$ 为奇数时, 可能存在一条平分圆的对角线在置换下不变, 计算 $\frac{N+1}{2}$ 个点的答案即可. 考虑旋转置换.为了满足旋转之后的边重合, 点 $i$ 和它的匹配点 $p_i$ 在旋转后应该仍然是相匹配的.则环的数量一定是偶数 $2d$, 所以环的长度可以表示为 $\frac{2N}{2d} = \frac{N}{d}$. 假定置换的阶是 $e$, $e &gt; 1, e | N$, 环的数量 $2d = \frac{2N}{e}$.环上与 $0$ 匹配的点为 $i$, 不难发现在这些点之间的点的方案数为 $C_{i-1}$.当这些点确定之后, 它们在环上依次经过的 $e(i+1)$ 个点就确定了. 令 $f(x)$ 表示 $\mathrm{Catalan}$ 数的生成函数, 根据 $\mathrm{Catalan}$ 数的递推式, 不难得到: f(x) = xf^2(x) + 1构造 $B_d$ 表示包含 $2d$ 个环的置换下不动点的数量. B_d = 2\sum_{i = 0}^{d-1} C_i B_{d-i-1}其中因子 $2$ 考虑的是 $i &gt; 2d$ 时用当前置换的逆来计算的情况. 则 $B_d$ 的生成函数 $g(x)$ 满足: g(x) = 2x g(x) f(x) + 1解得: g(x) = (1 - 4x) ^ {-\frac{1}{2}}问题解决p(n) = \frac{1}{2n} ( [\mathrm{n \, is \, odd}]\binom{n}{\lfloor\frac{n}{2}\rfloor} - \binom{2n}{n-1} + \sum_{d|n}{\varphi(n/d)\binom {2d}{d}} )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写在NOIP2017之后]]></title>
      <url>%2F2017%2Fafter-noip-2017%2F</url>
      <content type="text"><![CDATA[引 本来应该有另一篇博客叫做写在NOIP2017之前的, 但跑回家才意识到博客搭在机房的电脑上, 于是…… 比赛过程Day1看到这个T1不送分了, 心里还是有点虚, 认真地读完了后面两题平复了一下心态.想着既然是T1, 肯定不是送就是偷, 看着样例找了找规律, 推了个 $ a + b + (b \% a) (a &lt; b) $ 的方法, 发现过不了大样例. 于是盯着大样例发呆, 突然发现了世界的奥秘.然后写T2, 写完眼查了一下大样例, 正要关闭窗口的时候 Vimdiff 了一波, 发现自己大小写写错一大堆…T3想了想写了个不考虑零边的记忆化搜索, 发现大样例过不了 认真思考了一下发现是没有考虑到达终点又折返的情况 又想了想发现 $-1$ 挺好判的, 就加上了. Day2到达考场时精神状态不太好, 意识模糊地打开了题目.看完T2一直在想MST什么的, 感觉不太会做准备放弃时发现数据范围只有12, 于是秒懂了.T3没想多久推出一个平衡树的做法, 对自己代码能力过于自信没有多想就开始写, 结果调到最后一刻还是GG了. 反思错误感觉这次虽然题目比较奇怪, 但实际难度还是合理的, 出现了一些失误恰恰暴露出身上的一些问题. 考试的时候大部分处在一种边想边写的状态, 一边写可能还要一边完善一些细节. 刷了很多Atcoder 的题目之后, 代码能力退化明显. 考场的debuff比较强. 可能后面两条还稍微可以接受吧, 但是第一条的确是硬伤, 这样做简单题或者在比较清醒的时候写题可能还好, 然而一旦遇到代码实现比较复杂或者条件比较多的题目, 就会挂得很惨, 这个问题模拟赛中也出现过几次.解决的策略其实说起来也不难, 主要就是每道题写之前把算法细节考虑基本清楚, 做到 $ Think \,\, twice, Code \,\, once $ 吧. 这样也不会出现某道题写了很久最后发现做法是错误的这种尴尬的情况也能够避免写一些特别复杂的做法. 关于未来针对这次联赛的问题和原来的一些弱点, 对接下来的一段学习做一些规划： 补一些数学相关的知识（不一定OI相关） 提高一下代码能力, 复习一些不熟练的数据结构, 刷一些质量比较高的题目 然后的话, 回去就要补文化了吧.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTSC2017 游戏]]></title>
      <url>%2F2017%2Fctsc2017-game%2F</url>
      <content type="text"><![CDATA[Description 有$N$ 局游戏, 除第一局游戏外每一局游戏的获胜机率均与上一局游戏的结果有关. 现在对游戏进行$Q$次修改, 每次告诉你某一局游戏的结果或者删除之前给你的信息, 求修改后期望下获胜的场数为多少. $ N, Q \le 2 \times 10 ^ 5 $ Solution首先不难发现, 某一局的游戏的胜率只与其左右的最近游戏结果相关, 所以答案可以分段计算. 考虑期望的线性性, 可以将期望胜利场数表示成每一局游戏的胜率之和.记 $X _ i$ 表示第$i$ 场游戏的状态. 所求即为 $ \sum _ {l &lt; m &lt; r} P( X _ m = 1 | X _ l, X _ r) $. 由贝叶斯公式: \begin{align} P(X _ m = 1 | X _ l, X _ r) &= \frac{P(X _ m = 1, X _ l, X _ r)}{P(X _ l) \cdot P(X _ r | X _ l) } \\ &= \frac{P(X _ l) \cdot P(X _ m = 1 | X _ l) \cdot P(X _ r | X _ l, X _ m = 1)}{P(X _ l) \cdot P(X _ r | X _ l)} \\ &= \frac{P(X _ m=1 | X _ l) \cdot P(X _ r | X _ l, X _ m = 1)}{P(X _ r | X _ l)} \\ &= \frac{P(X _ m=1 | X _ l) \cdot P(X _ r | X _ m = 1)}{P(X _ r | X _ l)} \end{align}发现分母是常数, 于是可以合并分子.考虑分子的意义, 大概是合法状态下当前位置为胜的概率.每一段就可以直接用$dp$来处理出答案, 记录某场比赛为胜/ 负的概率以及分子的期望即可.这个复杂度是每次询问$O(n)$的. 其实这道题要讲的已经讲完了, 最后只要用矩乘快速合并$dp$值, 维护一下就可以了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[两道概率题]]></title>
      <url>%2F2017%2Fprobability-problems%2F</url>
      <content type="text"><![CDATA[玛里苟斯Description 给你一个大小为N的可重集合, 求该集合子集异或和的$K$次方的期望, 保证答案不超过$2 ^ {64}$. $N \le 100000, K \le 5, A _ i \le 10 ^ 9$ Solution&emsp;&emsp; $K=1$ 时满足期望的线性性, 可以对每一个二进制位分开计算答案. 不难发现每一个二进制位变成 $1$ 的概率恰好为 $\frac {1}{2}$ (集合的奇数和偶数大小的子集数相同). &emsp;&emsp; $K=2$ 时要求的是期望的平方, 即: \sum_{i=0}^{32} \sum_{j=0}^{32} b_i b_j 2^{i+j}其中 $b_i$表示期望二进制第 $i$ 位的值, 枚举两个二进制位再求一下两个位置同时取到 $1$ 的概率即可. &emsp;&emsp; $K \ge 3$时由于答案不超过 $2^{64}$, 所以集合内的数也不会很大, 直接用线性基处理. 主旋律Description 求N个点, M条边的有向图有多少生成子图满足整个图是强联通的. $N \le 15, M \le N(N-1)$ Solution&emsp;&emsp; 这题一眼看上去不太好做, 不妨从问题的反面来考虑. 首先一个非强联通的图缩掉$Scc$ 之后会得到若干个 $DAG$. 如果知道$Scc$ 的划分情况, 计算$DAG$ 的数量就变成一个经典问题了: E(S, T) = {|\{(u, v) \in E | u \in S, v \in T)\}|}F(S) = \sum _ {T \subset S, T \neq \varnothing} (-1) ^ {|T| - 1} \times 2 ^ {E(T, S-T)} F(T)&emsp;&emsp; 然而感觉枚举$Scc$ 划分更不可做. 先不考虑$Scc$ 如何划分, 考虑哪一些点集构成多少个$Scc$. 假设$G _ K(T)$表示$T$ 集合分成$K$ 个$Scc$ 的方案数, 类似上面式子地, 有: F(S) = \sum _ {T \subset S, T \neq \varnothing} \sum _ {K = 1}^{|T|} (-1) ^ {K - 1} \times G _ K(T) \times 2 ^ {E(T, S-T) + E(S-T, S-T)}DP(S) = 2 ^ {E(S, S)} - F(S)&emsp;&emsp; 实际上只需要求将某个集合分成奇数个$Scc$ 与偶数个$Scc$ 的方案数之差 $P(S)$: P(S) = DP(S) + \sum _ {T \subset S, u \in T} - DP(T) \times P(S - T) 其中 $u \in T$ 避免重复计数. &emsp;&emsp; 这样加上一些预处理的技巧可以做到 $O(3 ^ n)$.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Atcoder 选做]]></title>
      <url>%2F2017%2Fatcoder-select%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp; 其实是总结一下比赛中遇到的好题, 然后瞎做了几场 AGC 的题目练习, 感觉还比较有意思. AGCAGC002 F Leftmost Ball 给你$N$种不同颜色的球, 每种有$K$个, 现在你可以将球任意排列, 但最终的序列中每种颜色的第一个出现位置要被染成$0$颜色, 求能够得到的本质不同的序列数, 对$10^9 + 7$取模. $N, K \leq 2000$ &emsp;&emsp; 这题正着处理没有什么思路, 但是如果从右往左来会比较好考虑. 我们可以记$f(i, j)$表示当前从右往左填剩下$i$个$0$颜色的球, 还剩下$j$种颜色没有放的方案数. 那么每一次的决策就包括放入一个$0$颜色的球以及添加一种颜色的$k-1$个球: \begin{aligned} f(i-1, j) & \leftarrow f(i, j) \mid [i > j] \\ f(i, j-1) & \leftarrow f(i, j) \times {n-i + (n-j) \times (k-1) + k-2 \choose k-2} \end{aligned} 后面那个公式是可重集, 还有最后的答案要乘以$n!$. AGC005 D ~K Perm Counting 求长度为$N$的排列中, 满足对任意的$i$, 都有$|a_i - i| \neq K$的排列数量. $1 \leq K &lt; N \leq 2000$ &emsp;&emsp; 考虑容斥, 计算至少有$i$个位置不合法的方案数. 由于$K$是确定的, 那么所有不合法的方案可以看成是完全二分图匹配中出现了一条$(i, i+k)$的边或者一条$(i, i-k)$的边. &emsp;&emsp; 将这样的边在画出来就是若干条交叉路径. 观察到这样的交叉路径不相交, 所以可以拆开拼成一个序列, 然后在序列上$dp$即可. AGC015 D A or…or B Problem 求在$[A, B]$中任意选出一个非空整数集合的元素位或和有多少种不同的答案. $1 \le A \le B \le 2^{60}$ &emsp;&emsp; 先考虑一些比较特殊的情况(以下默认$A, B$的位数相同): 当$B$可以表示为$2^k - 1$时, 这个位或和恰好取遍$[A, B]$之间的所有整数. 当$A$可以表示为$2^k$时, 这个位或和在区间$[A, A + 2^{t+1}) \mid t &lt; log_2 A$中, 其中$t$是最大的满足$B$的第$t$位为$1$的数. &emsp;&emsp; 那么一般情况下这些条件有什么用呢? &emsp;&emsp; 我们考虑找到最大的一个$T$,使得$B$的第$T$位为$1$且$A$的第$T$位不为$1$, 记$K = 2 ^ T$. 当选择的数的集合在$[A, K)$以及在$[K, B]$中的情况可以直接用上述结论. &emsp;&emsp; 接下来考虑同时选取两个集合中的数可能会产生的答案. 因为这时小于$K$的部分是没有贡献的, 所以直接将$[A, K)$中的所有答案取出. 不难发现$[K, B]$中取任意个都与只使用$K$没有区别, 那么这时候的范围是$[K+A, 2\times K-1]$, 注意减去重复贡献. AGC015 F Kenus the Ancient Greek Q组询问, 每组询问的形式为A, B, 表示求$x \in [1, A], y \in [1, B]$的$g(x, y)$的最大值, 及最大值的方案数, 其中: g(x, y) = \begin{cases} 1, & \text{y = 0} \\ g(y, x), & \text{x > y} \\ g(y \; mod \; x, x) + 1, & \text{otherwise} \\ \end{cases}$1 \le Q \le 3 \times 10 ^ 5 \,\,, 1 \le A, B \le 10 ^ {18}$ &emsp;&emsp; 以下无特殊说明, 均默认所有$x &lt; y, A &lt; B$ &emsp;&emsp; 先考虑第一问, 如果我们由一个特定的$(x, y)$, 从小到大地构造使得$g(x, y)$的值不断地变大, 那么如何构造使得这个值最大呢? &emsp;&emsp; 对于所有$(x’, y’)$满足$g(x’, y’) = g(x, y) + 1$, 显然有: (x', y') \in \{ (y, x + ky) \mid k \in Z^+ \}&emsp;&emsp; 同时, 为了使得这个过程尽可能的多次进行,我们从$(0, 1)$出发, 每次取$k = 1$.发现这样生成了一组$Fibonacci$数列, 这里$Fibonacci$数列从0开始标号. &emsp;&emsp; 那么第一问的答案就是求满足$Fib_k \le A,\; Fib_{k+1} \le B$的最大的$k$. 同时, 这样的数对是满足$g(x, y) = k$的最小的数对. &emsp;&emsp; 接下来考虑统计方案数. 首先, 对于一组询问我们只需考虑其中与最优解相关的$(x, y)$. &emsp;&emsp; 考虑所有最优的$(x, y)$会具有的性质: $x \ge Fib_k, \; y \ge Fib_{k+1}$ 不存在一组$(x’ &lt; x, y’ &lt; y)$, 使得$g(x’, y’) &gt; g(x, y)$ 然而这样的$(x, y)$并不一定是最优的. &emsp;&emsp; 我们接着分析所有在最优解的$g$的计算路径上的数对$(x, y)$的性质: 不难发现, 经过一次变化后得到的$(x’, y’)$, 一定满足: $g(x’, y’) = k-1$ $x’ \ge Fib_{k-1}, y’ \ge Fib_{k}$ $y’ \le Fib_{k+1} + Fib_{k-2}$ &emsp;&emsp; 后面条件的解释: 若$y’ &gt; Fib_{k+1} + Fib_{k-2}$, 则 (x, y) = (y' > Fib_{k+1} + Fib_{k-2} > Fib_{k+1}, x' + py' \ge x' + y' > Fib_{k+2}), $(x, y)$不再满足上述最优性质2, 矛盾. &emsp;&emsp; 同时每次向下一步进行构造的时候只有$(Fib_k, Fib_{k+1})$可能取到$p = 2$所以这样的数对个数是$O(k)$的. 所以我们预处理所有的这样的数对, 然后用除法算下答案就好了. &emsp;&emsp; 复杂度$O(log^2{MAX} + QlogMAX)$. ARCARC 的题目主要来源是打过的几场比赛, 暂时不多. ARC074 E RGB Sequence 给你一个长度为$N$的序列和$M$组约束条件, 每组条件形如$L_i, R_i, X_i$, 表示序列上的$[L_i, R_i]$中恰好有$X_i$种颜色, 现在要你用三种颜色给这个序列染色, 求满足所有约束的方案数. $1 \le N, M \le 300$ &emsp;&emsp; $dp$的思路应该比较显然, 然而普通的状态表示不太好处理. 我们记$dp_{r, g, b}$表示三种颜色的球最后一次出现的位置分别是$r, g, b$时的方案数. &emsp;&emsp; 然后考虑状态的合法性, 可以把条件存在$R_i$的位置. 当选择一个状态时, 考虑这个状态的最末位的所有约束即可. ARC077 F SS 定义一个字符串为偶的, 当且仅当这个字符串能够被分成两个完全相同的字符串. &emsp;&emsp; 定义函数$f(s)$, 其中$s, f(s)$均是字符串,$f(s)$为在字符串$s$后添加非空的字符满足新串为偶且长度最小的串. 现在给你串$s$(初始为偶的), 求$f^{10^{100}}(s)[L, R]$中各个字母的出现次数.$1 \le |S| \le 2\times 10^5$$1 \le L \le R \le 10^{18}$ &emsp;&emsp; 首先对于一个给定的$s$, 其$f(s)$必定唯一. 考虑每次最少加一个字符,$f^{10^{100}}(s)$就等价于一个长度无穷的字符串. 这个答案的形式显然可以前缀和, 又因为$s$在变化过程中始终是偶的, 实际上我们只需要关注左半部分的字符. &emsp;&emsp; 我们从最简单的一次操作来考虑. 记初始的字符串$s$为$SS$, 记一次变化之后左边的部分为$ST$, 那么得到的新串就是$STST$. 要使得加的字符长度最小, 就要在$S$中找到最长前后缀匹配长度, 这时$T$就是$S$去掉最长匹配后缀所得. &emsp;&emsp; 我们发现, 每次操作都等价于找到前后缀匹配最大长度(当然要小于$|S|$), 然后将剩下部分的前缀$T$添加到$S$的末尾. 当$|T| \mid |S|$时,$|S|$有长为$|T|$的最小周期, 每次加入的$|T|$相同. 当$|T| \nmid|S|$时, 我们通过打表发现, 这样的$T$是在有规律地变化的, 因为每次加入$T$之后的串前后缀最长匹配一定是$|T|$, 否则的话, 上一步中最长匹配的性质就不一定会满足. &emsp;&emsp; 然后我们得到了一个$Fibonacci$数列? 直接暴力算就好了… 实际上第一种情况也可以直接算, 因为整个序列都是$T$的若干次重复得到的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces Div2 418E]]></title>
      <url>%2F2017%2Fcf-418e%2F</url>
      <content type="text"><![CDATA[Description 求满足如下条件的 $N$ 个点的简单无向图的个数对 $ 1e9 + 7 $ 取模的结果： 每个点的度数均为 $2$ 或 $3$ 从一号点到任何一个点的最短路唯一并且随着点标号上升而不降. (两个图不同当且仅当边的集合不同).$N &lt;= 50$ Solution我们可以记: $f_{i, j}$ 表示考虑完前 $i$ 个点, 最后一层恰好有 $j$ 个点, 且最后一层之前的点度数已经满足条件时的方案数. $g_{i, j, k}$ 表示当前层有 $i$ 个点, 上一层剩下来 $j$ 个度为 $2$ 的点, $k$ 个度为 $3$ 的点时连边的方案数. 那么容易得到$f_{i, j} = \sum_{k} f_{i-j, k} \times g_{j, c0, c1}$, 其中$c0\,,c1$表示最后一层 $k$ 个点中度为 $2$ 的点和度为 $3$ 的点的个数. 对于 $g$, 不难得到: g_{i, j, k} = \begin{cases} 1 & i = 0, j = 0, k = 0 \\ \sum_{l=2}^{k-1} \frac{l!}{2} {k-1 \choose l} g_{i, j, k-l-1} & i = 0, j = 0, k > 0 \\ (j-1) \cdot g_{i, j-2, k} + k \cdot g_{i, j, k-1} & i = 0, j > 0 \\ j \cdot g_{i-1, j-1, k} + k \cdot g_{i-1, j+1, k-1} & i > 0 \end{cases}Hint注意在第二个递推式中 $l$ 从 $2$ 开始枚举, 因为不能有重边, 所以不存在大小为 $2$ 的环.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZJOI2017 树状数组]]></title>
      <url>%2F2017%2Fzjoi2017-bit%2F</url>
      <content type="text"><![CDATA[Description 给你一个长度为 $N$ 的序列以及 $M$ 次操作, 每次等概率地修改 $[L_i, R_i]$ 区间中一个值的奇偶性, 或者对于询问$[L_i,R_i]$区间中的和的奇偶性, 判断给定的一种错误算法输出正确答案的概率是多少$ N, M &lt;= 10^5 $ Solution考虑这个错误算法, 由于可以把 $ + lowbit $ 和 $ - lowbit $ 都看成在一棵树上向父亲节点跳, 根据这个性质可以知道错误算法求了一个后缀和, 所以当且仅当对于询问区间 $[L_i, R_i]$, 满足 $ a[L_i-1] = a[R_i] $ 时它会输出正确答案 那么我们得到了一个 $ O(nm) $ 的暴力算法, 即每一个询问都暴力扫之前的所有修改计算概率即可. 然而这样还不能通过所有数据, 考虑将区间 $[L_i, R_i]$ 表示成二维平面上的一个点 $ (L_i, R_i)$. 然后用一个二维线段树去维护每个点代表的两个端点的值不相等的概率.显然地, 这个概率是可以很方便的合并的.这样对于每次修改$[L_i, R_i]$的操作, 相当于: 将 $ x \in [L_i, R_i], y \in [L_i, R_i] $ 中的点 $(x, y)$ 与 $ \frac{2}{R_i - L_i+1} $ 合并. 将 $ x \in [L_i, R_i], y \in (R_i, N] $ 以及 $ x \in [0, L_i), y \in [L_i, R_i] $ 与 $ \frac{1}{R_i - L_i+1} $ 合并. Hint注意到对于 $ L_i = 1 $ 的情况, $ Find(0) $ 直接返回了 $0$ 而非 $0$ 的后缀和这个时候就要特判一下了, 注意到每次不管如何修改, 最终的正确答案是 $R_i$ 的前缀和, 而题中所给的方法输出的答案是 $R_i$ 的后缀和. 当前修改次数为偶数, 则当且仅当 $R_i = 0$ 前后缀和相同, 相当于查询 $a[R_i] = 0$ 的概率. 当前修改次数为奇数, 则当且仅当 $R_i = 1$ 前后缀和相同, 相当于查询 $a[R_i] = 1$ 的概率. 因为 $a[0]$ 不可能被修改, 所以上述问题也可以转化为查询 $[L_i, R_i]$ 相等概率. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define fst first#define snd second#define pb push_back#define getchar getchar_unlockedtemplate &lt;typename T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template &lt;typename T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;const int oo = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int mod = 998244353;int read() &#123; int n = 0, f = 1; char ch = getchar(); for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1; for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; return n * f;&#125;inline int merge(int a, int b) &#123; return (a * (1LL - b + mod) % mod + b * (1LL - a + mod) % mod) % mod;&#125;int N, M, prob;namespace Seg_Tree &#123; const int SZ_X = (maxn &lt;&lt; 2) + 5; const int SZ_Y = (maxn * 400) + 5; int rt[SZ_X]; int val[SZ_Y]; int lc[SZ_Y], rc[SZ_Y], cnt;#define LC (u &lt;&lt; 1) #define RC (LC | 1)#define mid ((l+r) &gt;&gt; 1) void Add_Y(int&amp; u, int l, int r, int x, int y) &#123; if(!u) u = ++cnt; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; val[u] = merge(val[u], prob); return; &#125; if(x &lt;= mid) Add_Y(lc[u], l, mid, x, y); if(y &gt; mid) Add_Y(rc[u], mid+1, r, x, y); &#125; void Add_X(int u, int l, int r, int x, int y, int x0, int y0) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; Add_Y(rt[u], 0, N, x0, y0); return; &#125; if(x &lt;= mid) Add_X(LC, l, mid, x, y, x0, y0); if(y &gt; mid) Add_X(RC, mid+1, r, x, y, x0, y0); &#125; int query_Y(int u, int l, int r, int x) &#123; if(l == r) return val[u]; return merge(val[u], x &lt;= mid ? query_Y(lc[u], l, mid, x) : query_Y(rc[u], mid+1, r, x)); &#125; int query_X(int u, int l, int r, int x, int x0) &#123; if(l == r) return query_Y(rt[u], 0, N, x0); return merge(query_Y(rt[u], 0, N, x0), x &lt;= mid ? query_X(LC, l, mid, x, x0) : query_X(RC, mid+1, r, x, x0)); &#125;&#125;int fpm(int base, int exp) &#123; int res = 1; for(; exp &gt; 0; exp &gt;&gt;= 1) &#123; if(exp &amp; 1) res = 1LL * res * base % mod; base = 1LL * base * base % mod; &#125; return res;&#125;int tot = 0;void solve() &#123; N = read(); M = read(); while(M--) &#123; static int ty, l, r; ty = read(); l = read(); r = read(); if(ty == 1) &#123; static LL tmp; tmp = fpm(r-l+1, mod-2); prob = 2*tmp; Seg_Tree::Add_X(1, 0, N, l, r, l, r); prob = tmp; Seg_Tree::Add_X(1, 0, N, l, r, r+1, N); prob = tmp; Seg_Tree::Add_X(1, 0, N, 0, l-1, l, r); ++ tot; &#125;else &#123; static int ans; ans = (1-Seg_Tree::query_X(1, 0, N, l-1, r)+mod) % mod; if(!(l-1) &amp;&amp; (tot &amp; 1)) ans = (1-ans+mod) % mod; printf("%d\n", ans); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NOI2016 网格]]></title>
      <url>%2F2017%2Fnoi2016-grid%2F</url>
      <content type="text"><![CDATA[Description 给出一个 $ N \times M $ 的网格图和图上的 $ C $ 个障碍物, 求最少删去多少个点可使得原图空格不四连通.$ N, M &lt;= 10 ^ 9, C &lt;= 10 ^ 5 $ Solution我们可以发现, 可能的答案只有 $ \{ -1, 0, 1, 2 \} $ 几种. 考虑一些简单的情况:答案等于 $ -1 $ 时, 点数小于 $2$ 或者恰好有两个相邻的点.答案为 $ 0 $ 时, 显然原图不连通. 那么就只需知道答案是否为 $ 1 $, 发现答案等于 $ 1 $ 当且仅当原图存在割点, 暴力的话不难做到 $ O(n * m) $. 将到达每个障碍的曼哈顿距离不超过 $2$ 的空格给提出来, 然后在这些点中找出一个割点, 满足到达最近的障碍的距离不超过 $1$.这样的点就一定是原图中的割点. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define fst first#define snd second#define pb push_backtemplate &lt;typename T&gt; bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template &lt;typename T&gt; bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;const int maxn = 2.5e6 + 10;const int oo = 0x3f3f3f3f;template&lt;typename T&gt; T read() &#123; T n = 0, f = 1; char ch = getchar(); for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1; for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; return n * f;&#125;struct Hash_Map &#123; static const int mod = 1666667; int cnt = 0; int st[mod], nxt[maxn], X[maxn], Y[maxn]; inline void clear() &#123; cnt = 0; memset(st, 0, sizeof st); &#125; inline int idx(int x, int y) &#123; return ((233LL*x + (y^888))%mod + mod)%mod; &#125; int find(int x, int y) &#123; int u = idx(x, y); for(int i = st[u]; i; i = nxt[i]) if(X[i] == x &amp;&amp; Y[i] == y) return i; return -1; &#125; int insert(int x, int y) &#123; int u = idx(x, y); for(int i = st[u]; i; i = nxt[i]) if(X[i] == x &amp;&amp; Y[i] == y) return i; ++ cnt; X[cnt] = x, Y[cnt] = y; nxt[cnt] = st[u]; st[u] = cnt; return cnt; &#125;&#125;HM;LL n, m, c;const int dx[] = &#123; 0, 1, 0, -1, 1, -1, 1, -1 &#125;;const int dy[] = &#123; 1, 0, -1, 0, 1, -1, -1, 1 &#125;;int st[maxn], nxt[maxn &lt;&lt; 3], to[maxn &lt;&lt; 3], ecnt = 1;void addedge(int x, int y) &#123; to[++ecnt] = y; nxt[ecnt] = st[x]; st[x] = ecnt; to[++ecnt] = x; nxt[ecnt] = st[y]; st[y] = ecnt;&#125;int vis[maxn];int mark[maxn], now = 0;void init() &#123; ecnt = 1; HM.clear(); memset(st, 0, sizeof st);&#125;int flood_fill(int u) &#123; int res = 1; mark[u] = now; for(int i = st[u], v; i; i = nxt[i]) if(mark[v = to[i]] != now) res += flood_fill(v); return res;&#125;int area_count(int s) &#123; return ++ now, flood_fill(s); &#125;int chk() &#123; if(n*m-c &lt; 2) return -1; int res = area_count(c + 1); if(n*m == 2 || (res == 2 &amp;&amp; n*m-c == 2)) return -1; return -2;&#125;bool flag;int dfn[maxn], low[maxn], dfs_clock = 0;bool dfs(int u, int fa, bool f = false) &#123; low[u] = dfn[u] = ++dfs_clock; for(int i = st[u], v; i; i = nxt[i]) if((v = to[i]) ^ fa) &#123; if(!dfn[v]) &#123; if(dfs(v, u)) return true; if(vis[u] == 1 &amp;&amp; (low[v] &gt; dfn[u] || (!f &amp;&amp; low[v] == dfn[u]))) &#123; return true; &#125; chkmin(low[u], low[v]); &#125;else chkmin(low[u], dfn[v]); &#125;&#125;bool chk1() &#123; flag = 0; memset(dfn, dfs_clock = 0, sizeof dfn); for(int i = c+1; i &lt;= HM.cnt; i++) if(!dfn[i]) &#123; if(dfs(i, 0, 1)) return 1; &#125; return 0;&#125;#define x(i) HM.X[i]#define y(i) HM.Y[i]//char ch[1000][1000];int X[maxn], Y[maxn], idx[maxn];bool chk0() &#123; memset(idx, 0, sizeof idx); memset(vis, 0, sizeof vis); for(int i = 1; i &lt;= c; i++) HM.insert(X[i], Y[i]); for(int v = 1; v &lt;= c; v++) if(!vis[v]) &#123; vector&lt;int&gt; V; static int q[maxn]; int head = 0, tail = 0; ecnt = 1; vis[q[tail++] = v] = 3; while(head &lt; tail) &#123; int h = q[head++]; for(int i = 0; i &lt; 8; i++) &#123; int nx = x(h) + dx[i]; int ny = y(h) + dy[i]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.insert(nx, ny); st[Nxt] = 0; if(Nxt &lt;= c) &#123; if(!vis[Nxt]) &#123; vis[Nxt] = 3; q[tail++] = Nxt; &#125; &#125;else if(idx[Nxt] != v) &#123; idx[Nxt] = v, V.pb(Nxt); &#125; &#125; &#125; &#125; for(int i = 0; i &lt; int(V.size()); i++) &#123; int u = V[i]; for(int j = 0; j &lt; 2; j++) &#123; int nx = x(u) + dx[j]; int ny = y(u) + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.find(nx, ny); if(idx[Nxt] == v) addedge(u, Nxt); &#125; &#125; &#125; if(V.size() &amp;&amp; area_count(V[0]) != int(V.size())) return true; &#125; return false;&#125;void build() &#123; memset(vis, 0, sizeof vis); int tail = 0; static int q[maxn]; for(int i = 1; i &lt;= c; i++) HM.insert(X[i], Y[i]), vis[i] = 3; for(int i = 1; i &lt;= c; i++) for(int j = 0; j &lt; 8; j++) &#123; int nx = X[i] + dx[j]; int ny = Y[i] + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.insert(nx, ny); if(!vis[Nxt]) &#123; vis[Nxt] = 1; q[tail++] = Nxt; &#125; &#125; &#125; int lim = tail; for(int i = 0; i &lt; lim; i++) &#123; for(int j = 0; j &lt; 8; j++) &#123; int nx = x(q[i]) + dx[j]; int ny = y(q[i]) + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.insert(nx, ny); if(!vis[Nxt]) &#123; vis[Nxt] = 2; q[tail++] = Nxt; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; tail; i++) &#123; for(int j = 0; j &lt; 2; j++) &#123; int nx = x(q[i]) + dx[j]; int ny = y(q[i]) + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.find(nx, ny); if(Nxt &gt; c) addedge(q[i], Nxt); &#125; &#125; &#125;&#125;int spe() &#123; int res = 0; if(n == 1) &#123; Y[++c] = 0; Y[++c] = m+1; sort(Y+1, Y+c+1); for(int i = 2; i &lt;= c; i++) if(Y[i] - Y[i-1] &gt; 1) ++ res; &#125;else &#123; X[++c] = 0; X[++c] = n+1; sort(X+1, X+c+1); for(int i = 2; i &lt;= c; i++) if(X[i] - X[i-1] &gt; 1) ++ res; &#125; return res &gt;= 2 ? 0 : 1;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif for(int T = read&lt;int&gt;(); T--; ) &#123; init(); n = read&lt;int&gt;(); m = read&lt;int&gt;(); c = read&lt;int&gt;(); for(int i = 1; i &lt;= c; i++) &#123; X[i] = read&lt;int&gt;(); Y[i] = read&lt;int&gt;(); &#125; if(chk0()) &#123; puts("0"); continue; &#125; init(); build(); static int ans; if((ans = chk()) != -2) &#123; &#125; else if(min(n, m) == 1) &#123; ans = spe(); &#125; else &#123; ans = chk1() ? 1 : 2; if(c == 0) ans = min(n, m) == 1 ? 1 : 2; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces 553E Kyoya and Train]]></title>
      <url>%2F2017%2Fcf-553e%2F</url>
      <content type="text"><![CDATA[Description 给定 $N$ 个点, $M$ 条边的有向图.每条边有花费: 通过第 $i$ 条边的时间有 $ P _ {i1} $ 的概率为 $1$, $P _ {i2}$ 的概率为 $2$…如果总用时超过 $T$ 则会被罚钱 $X$ 元, 求从 $1$ 号点到 $n$ 号点的最小期望花费.$ N \leq 50, M \leq 100, T \leq 100000 $ Solution考虑暴力DP, 记状态 $ dp _ {i, t} $ 表示到达 $i$ 号点, 且经过的时间为 $t$ 的最小期望花费, 转移十分显然.同时因为状态之间按照时间构成一个拓扑图, 所以转移不存在环. 可以记 $S _ {e, t}$ 表示边 $e$ 在时刻 $t$ 之后后继状态的最小期望花费. 则可以用下面这个式子计算 $dp _ {e, t}$: dp _ {i, t} = min \left\{ S _ {e, t} + cost _ e \right\}$e$ 是 $i$ 的出边. 接下来考虑如何计算 $S(e,t)$, 利用定义: S _ {e, t} = \sum _ {i = 1}^{T} dp _ {to _ e, t + i} * P _ {ei}这样变成卷积形式, 分治 $FFT$ 即可. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;const int oo = 0x3f3f3f3f;const int maxn = 200000 + 10;const double PI = acos(-1.0);template &lt;typename T&gt; bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template &lt;typename T&gt; bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;#define fst first#define snd second#define debug(x) cerr &lt;&lt; #x &lt;&lt; ":" &lt;&lt; (x) &lt;&lt; endl#define REP(i, a, b) for(int i = (a), i##end = (b); i &lt; i##end; ++i)#define DREP(i, a, b) for(int i = (a)-1, i##bgn = (b); i &gt;= i##bgn; --i)template&lt;typename T&gt; T read() &#123; T n = 0, f = 1; char ch = getchar(); for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1; for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; return n * f;&#125;struct Complex &#123; double real, imag; Complex(double r = 0.0, double i = 0.0): real(r), imag(i) &#123;&#125; Complex operator + (const Complex&amp; rhs) const &#123; return Complex(real + rhs.real, imag + rhs.imag); &#125; Complex operator - (const Complex&amp; rhs) const &#123; return Complex(real - rhs.real, imag - rhs.imag); &#125; Complex operator * (const Complex&amp; rhs) const &#123; return Complex(real*rhs.real - imag*rhs.imag, real*rhs.imag + imag*rhs.real); &#125; Complex operator / (const double&amp; div) const &#123; return Complex(real / div, imag / div); &#125;&#125;;int rev[maxn];void DFT(Complex *x, int N, int t) &#123; for(int i = 0; i &lt; N; i++) if(i &lt; rev[i]) swap(x[i], x[rev[i]]); for(int l = 2; l &lt;= N; l &lt;&lt;= 1) &#123; Complex wn = Complex(cos(2*PI*t/l), sin(2*PI*t/l)); for(int i = 0; i &lt; N; i += l) &#123; Complex w = Complex(1, 0); for(int j = 0; j &lt; (l &gt;&gt; 1); j++, w = w * wn) &#123; Complex L = x[i + j]; Complex R = x[i + j + (l &gt;&gt; 1)] * w; x[i + j] = L + R; x[i + j + (l &gt;&gt; 1)] = L - R; &#125; &#125; &#125; if(!~t) for(int i = 0; i &lt; N; i++) x[i] = x[i] / N;&#125;const int N = 100 + 5;int dis[N][N];int n, m, t, x;struct Edge &#123; int u, v, c; double p[maxn]; void input() &#123; u = read&lt;int&gt;(), v = read&lt;int&gt;(), c = read&lt;int&gt;(); chkmin(dis[u][v], c); for(int i = 1; i &lt;= t; i++) p[i] = double(read&lt;int&gt;()) / 100000.0; &#125;&#125;E[N];Complex A[maxn], B[maxn];double S[N][maxn], f[N][maxn];void calc(int l, int r, int mid) &#123; static int base, len; for(int k = 0; k &lt; m; k++) &#123; int v = E[k].v; for(base = 1, len = 0; base &lt;= 2*r-l-mid+1; base &lt;&lt;= 1) ++ len; for(int i = 0; i &lt; base; i++) rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (len-1)); for(int i = 0; i &lt; base; i++) A[i] = B[i] = Complex(0, 0); for(int i = 0; i &lt; r-mid; i++) A[i] = Complex(f[v][r-i], 0); for(int i = 1; i &lt;= r-l; i++) B[i-1] = Complex(E[k].p[i], 0); DFT(A, base, 1); DFT(B, base, 1); for(int i = 0; i &lt; base; i++) A[i] = A[i] * B[i]; DFT(A, base, -1); for(int i = l; i &lt;= mid; i++) S[k][i] += A[r-i-1].real; &#125;&#125;void cdq_solve(int l, int r) &#123; if(l == r) &#123; for(int i = 0; i &lt; m; i++) chkmin(f[E[i].u][l], S[i][l] + E[i].c); return; &#125; int mid = (l + r) &gt;&gt; 1; cdq_solve(mid+1, r); calc(l, r, mid); cdq_solve(l, mid);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif memset(dis, oo, sizeof dis); n = read&lt;int&gt;(), m = read&lt;int&gt;(), t = read&lt;int&gt;(), x = read&lt;int&gt;(); for(int i = 1; i &lt;= n; i++) dis[i][i] = 0; for(int i = 0; i &lt; m; i++) E[i].input(); for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) chkmin(dis[i][j], dis[i][k] + dis[k][j]); for(int i = 1; i &lt;= n; i++) &#123; for(int T = 0; T &lt;= t; T++) f[i][T] = (i == n) ? 0 : oo; for(int T = t+1; T &lt;= 2*t; T++) f[i][T] = dis[i][n] + x; &#125; calc(1, t*2, t); cdq_solve(0, t); printf("%.10lf\n", f[1][0]); return 0;&#125;]]></content>
    </entry>

    
  
  
</search>
