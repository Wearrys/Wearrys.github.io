---
title: 初探可持久化数据结构
date: 2017-02-20
tags: Datastructure
---

### Example:
&emsp;&emsp;1.Hdu 4348 : 线段树区间修改，历史版本查询，操作回退。
&emsp;&emsp;2.Bzoj 2653: 给定左右端点的区间范围，求最大的可行中位数。
&emsp;&emsp;3.Spoj DQUERY: 给定区间求区间内不同数的个数。

### Tricks:
&emsp;&emsp;这两道题中的可持久化思路都非常巧妙，主要从主席树的思想延伸过来。
&emsp;&emsp;但又和一般的主席树有不同之处。

&emsp;&emsp;首先对于第一题，可以直接建一棵普通的线段树。
&emsp;&emsp;然后对每次的修改可以在原来的树上新建节点，新节点用于维护Add标记，若进行回退操作时直接回退到特定时间的标记即可。
&emsp;&emsp;这样相当于用一棵主席树来维护Add标记，但是不能下传标记，因为直接下传会导致主席树中新节点大量增多，浪费不必要的空间。而如果只维护Add的值，每次查询时再考虑它对答案的影响即可。这样每次添加的节点是logn级别的。
<!--more-->

&emsp;&emsp;然后对第二题，不难发现，具有单调性(可二分性),考虑如何简便地判断一个数字是否可行。
若在一棵线段树中将比当前数小的点权当成-1，比当前数大的当成1.
&emsp;&emsp;若存在一种方案使得合法的区间最大子段和 >= 0，那么说明中位数可以继续增大。
&emsp;&emsp;考虑如何求这个最大字段和，不难发现对每个数都对应一个不同的序列，所以直接算比较困难。但是同时又发现，如果将序列排序后再考虑这一点，每个点的数列旨在前一个点的基础上进行了一次点修改，于是可以主席树来维护这个值的变化序列，然后考虑区间分治的方法求最大子段和即可。

&emsp;&emsp;如何做第三题呢？首先如果只有这一组询问显然是很好做的，直接扫一遍即可。
&emsp;&emsp;然后考虑多组询问的情况如果将所有左区间相同的询问，可以将从这个点开始到最右端的数列离散化到一个表里，然后每次就在这个表里根据右区间的不同来计算答案。为了方便地查询答案，我们用数字的下标作为关键字来构造，当遇到相同的数字时就将其放在最左边的出现位置然后删去其他点的影响即可，然后每次查询就等价于求一次区间和。所以可以每一次将端点往左边移一位最多只有一次修改，直接构造类主席树即可。
