<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[若干趣题]]></title>
    <url>%2F2020%2Fexercise-of-thoughts%2F</url>
    <content type="text"><![CDATA[写在前面宅家没事的时候找的乐子，不定期更新，大概。 1Description有 $n$ 个人，其中有好有坏，每个人都知道其他任何人是好是坏，现在可以进行若干次询问，每次询问形如 $(i, j)$，表示问第 $i$ 个人第 $j$ 个人是否是好人 $(i \neq j)$，同时好人一定说真话，坏人可能说假话，问： 如果有多于一半的人是好的，是否存在策略能够在不超过 $n$ 次询问下确定一个好人。 如果有恰好一半的人是坏人，是否存在上述策略。 Solution1考虑维护一个序列，初始时加入编号为 $1$ 的人，接下来依次将其他人加入，每次加入的时候询问序列末尾的人这个人是好人还是坏人，如果答案是坏人则删除末尾，否则将这个新加入的作为末尾，正确性不难验证： 每次删除的至少有一个坏人，因此最后序列剩下的人中至少有一个好人。 如果序列中至少有一个好人，则序列的末尾一定也是好人。 2不能，如果所有坏人都永远说谎，则他们与好人没有区别。]]></content>
      <tags>
        <tag>Combinatorial</tag>
        <tag>Induction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互测题总结]]></title>
    <url>%2F2018%2Fproblem-select%2F</url>
    <content type="text"><![CDATA[StringDescription 称一个仅由a, b, c组成的字符串 $S$ 是平衡的当且仅当对于 $S$ 的任意一个连续子串 $T$, 任意两种字符的出现次数之差都小于等于 $k$, 求长度为 $n$ 的平衡串的数量. $n \le 10^9, K \le 8$ Solution定义 $f_{a, b}(i)$ 表示在前 $i$ 个字符中 a 和 b 出现次数之差, 在只考虑 a, b 两种字符的条件等价于: \max_{i=1}^{n} f_{a, b}(i) - \min_{i=1}^{n} f_{a, b}(i) \le k注意到如果 $f_{a, b}$ 的值域区间长度为 $len$, 则被所有长度为 $k$ 的值域区间计算的次数是 $k - len + 1$.记 $g(x, y, z)$ 表示三种 $f$ 的值域区间长度限制分别为 $x, y, z$ 时的方案数, 那么可以容斥计算答案: ans = g(k, k, k) - 3 g(k, k, k-1) + 3 g(k, k-1, k-1) - g(k-1, k-1, k-1)考虑如何计算 $g(x, y, z)$, 以 $x$ 为例, 每一个合法的区间一定可以表示成 $s_x + l_x \mid l_x \in [0, x]$ 的形式. 因为初始状态的 $l$ 确定了 $s$ , 接下来的转移只需要保证 $l$ 的范围即可, 由于: f_{a, b}(i) - f_{a, c}(i) = f_{c, b}(i)考虑对于 $z$ 的限制, 有: s_z + s_y - s_x \le l_x - l_y \le s_z + s_y - s_x + l_z每次转移之前枚举一下 $s_z + s_y - s_x$ 即可, 这样状态只需要考虑 $l_x, l_y$ 即可, 并且初始状态唯一确定 $s_x, s_y, s_z$. SequenceDescription 对长度为 $n$ 的序列 $\{a_i\}$, 定义 $sum(l, r)$ 为第 $l$ 到 $r$ 项的元素之和, $inc(l, r)$ 为第 $l$ 到 $r$ 项的非空上升子序列的最大权值和, 求 $\max_{1 \le l,\, r \le n} sum(l, r) - inc(l, r)$, 以及同时满足区间长度最小的 $(l, r)$ 的数量. $n \le 2 \times 10^5, |a_i| \le 40$ Solution由于权值的范围比较小, $inc$ 的范围也不大, 同时一定存在方案使得 $inc$ 中只包含正数. 考虑从左到右枚举右端点, 由于最小化区间长度的需要, 记录 $dp(i, j)$ 表示右边界不超过当前枚举的位置, 最长上升子序列的权值和为 $i$ 且最后一位的权值为 $j$ 时最靠右的左端点的位置. 转移可以做到 $O(n |a_i|^3)$ 接下来考虑计算答案, 从大到小枚举 $inc$ 可能的值, 并求其最靠右的左端点如果左端点是单调增的则说明选择中间这部分的左端点 $inc$ 会发生变化, 找一个能最优化 $sum$ 的同时区间长度最小的左端点即可. GameDescription $n$ 个人在一起玩游戏每个人初始有一张牌, 牌上的数字构成一个 $1-n$ 的排列, 所有人从左到右进行决策: 翻开自己的牌并留在原地, 或者选一个之前的人与其交换手中的牌并离开游戏, 之前的人将他的牌翻开. 每个人都会采取最佳策略, 并希望自己手中的牌上的数字尽可能大. 定义 $E(n)$ 为 $n$ 个人进行游戏最后留在原地的人的数量的期望. \begin{aligned} S_k(n) = \begin{cases} E(n) & \text{k = 0} \\ \sum_{i=1}^{n} S_{k-1}(i) & \text{otherwise} \\ \end{cases} \end{aligned}求 $S_k(n)$, 保留 $10$ 位有效数字. $k \le 50, n \le 10^{15}$ Solution首先需要分析每个人的策略, 已知的信息有两部分, 留在原地的人手中的数字集合$P$, 没有进行决策的人手中的数字集合$R$. 考虑证明最优策略下发生交换当且仅当 $\min\{R\} &lt; \max\{P\}$. 不妨使用数学归纳法证明, 对于最后一个做决策的人, 决策正确性显然, 考虑剩下的人: 当 $\min\{R\} &gt; \max\{P\}$ 时, 显然翻开手中的牌无论如何都不会再劣于 $\max\{P\}$. 当 $\min\{R\} &lt; \max\{P\}$ 时, 考虑反证翻开当前的牌不会比 $\max\{P\}$ 更优: 如果翻开的牌优于 $\max\{P\}$, 由于在这之前有 $\min\{R\} &lt; \max\{P\}$, 在最小值被翻出之前接下来的人都会选择与最大的位置交换, 如果最大值所在的位置没有发生变化这个位置最后会变成 $\min\{R\}$ 且不会有人再和他交换手中的牌, 否则这个位置需要先变得小于原本的 $\max\{P\}$. 如果翻开的牌劣于 $\max\{P\}$ 则类似上述情况中先变得小于原本 $\max\{P\}$ 的情况, 每一个完整过程中要么 $\max\{P\}$ 变成 $\min\{R\}$, 要么 $\max\{P\}$ 的位置发生变化, 最终一定都会劣于最初的 $\max\{P\}$. 接下来考虑 $E(n)$, 第 $i$ 个人选择留在原地当且仅当第 $i-1$ 个人手中的牌恰好是后缀最小值, 于是: E(n) = \sum_{i=1}^{n} \frac{1}{i}考虑生成函数: \begin{aligned} F(x) &= \sum_{i=1}^{\infty} \frac{1}{i} x^i \\ &= \int \frac{1}{1 - x} \\ &= -\ln(1 - x) \\ \end{aligned} \begin{aligned} E(x) &= \frac{F(x)}{1 - x} \\ &= \frac{-\ln(1 - x)}{1 - x} \end{aligned}接下来计算 $S_k(n)$: \begin{aligned} S_k(x) &= \frac{S_{k-1}(x)}{1 - x} \\ &= \frac{-\ln(1 - x)}{(1 - x)^{k + 1}} \\ S_k'(x) &= \frac{(-\ln(1-x))'}{(1-x)^{k + 1}} - \ln(1 - x) \left( \frac{1}{(1 - x)^{k+1}} \right)' \\ &= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \left( -\frac{1}{(1 - x)^{2k + 2}} ((1-x)^{k+1})' \right) \\ &= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \frac{(k + 1) (1 - x)^k}{(1 - x)^{2k+2}} \\ &= \frac{1}{(1 - x)^{k + 2}} + (k + 1) S_{k+1}(x) \end{aligned}考虑 $x^n$ 项的系数: (n+1)S_k(n+1)x^n = {n + k + 2 \choose k + 1}x^n + (k + 1) S_{k + 1}(n) x^nS_{k+1}(n) = \frac{(n+1)S_k(n+1) - {n + k + 2 \choose k + 1}}{k + 1}对于 $S_0(n)$, 使用调和级数的近似公式计算, 否则递归即可. PowerDescription $n$ 个连续随机变量, 第 $i$ 个变量 $x_i$ 在 $[l_i, r_i]$ 中均匀随机, 求 $\max\{ (\sum{x_i})^m, a^m \}$ 的期望值对 $998244353$ 取模的结果. $n \le 15, m \le 10^8, |a|, |l_i|, |r_i| \le 10^6$ Solution连续概率实际上是合法的点集在 $n$ 维超立方体中的体积占比, 点集内部用积分计算期望即可. 对于 $[0, \infty)$ 范围内的 $n$ 个连续随机变量 $\{x_i\}$, 不难归纳得到满足 $\sum x_i \le x$ 的点构成的 $n$ 维超几何体在 $n$ 维空间中的体积是 $\frac{x^n}{n!}$. 考虑 $\sum{x_i}$ 和 $a$ 的大小关系. $m$ 为奇数时, 需要考虑两个区间, $[-\infty, a], [a, \infty]$. $m$ 为偶数时, 需要计算三个区间的答案, $[-\infty, -a], [-a, a], [a, \infty]$. 那么要计算在每个区间内部的期望值, 考虑将每个 $x_i$ 表示为 $l_i + y_i$ 或 $r_i + y_i$, $2^n$ 枚举所有不合法的变量集合进行容斥, 对于 $\sum y_i \le K$ 的限制可以转化成计算: \int_{0}^{K} \frac{x^{n-1}}{(n-1)!} g(x) \mathrm{d}x$g(x)$ 表示当 $\sum y_i = x$ 时的答案, 同一个区间内的形式是相同的. 对于 $\sum y_i \ge K$ 的限制可以反过来将每个 $x_i$ 表示为 $r_i - y_i$ 或者 $l_i - y_i$, 限制 $-\sum y_i \ge K$ 可以转化为 $\sum y_i \le K$ 的形式. BiziDescription 给出两棵有根树, 大小分别是 $n_1, n_2$, 可以进行三种操作: 修改: 将一条边的边权从 $x$ 改为 $y$ , 代价为 $|x - y| \times c1$. 收缩: 选择一个点, 将它的所有子树连向他的父亲, 代价为这个点到父亲的边权 $w \times c2$. 生长: 选择任意一个点的一段连续的子树, 插入一个新点连向选择的点并成为这些子树的父亲, 代价为连向原来的点的边权 $w \times c2$. 求出使得两颗树括号序列和边权相同需要的最小代价. $n1 \le 50,\, n2 \le 2000$ Solution首先不难发现操作一和操作二互为逆操作, 所以可以只考虑操作二. 定义 $dp(a, b, c, d)$ 表示第一颗树中 $[a, b]$ 表示的括号序列区间和第二棵树中 $[c, d]$ 表示的括号序列区间变得相同需要的最小代价, 考虑左端点对应的括号在最终情况下的匹配情况进行转移: dp(a, b, c, d) = \min \begin{cases} dp(a + 1, b, c, d) + w_{a} \times c2 \\ dp(a, b, c + 1, d) + w_{c} \times c2 \\ dp(a + 1, p_{a} - 1, b + 1, p_{b} - 1) + dp(p_{a} + 1, b, p_{c} + 1, d) + |w_{a} - w_{b}| \times c1 \end{cases}$p_x$ 表示第 $x$ 个括号的匹配括号的位置, $w_x$ 表示第 $x$ 个括号和其父亲结点之间连边的边权. 看起来状态数是 $O(n1^2n2^2)$ 的, 实际上分析后发现有用的状态数只有 $O(n1^2n2\log{n2})$:因为考虑左端点进行转移和考虑右端点进行转移是等价的, 但是如果每次都选择第二棵树中子树大小较小的一侧进行转移, 关于第二棵树的状态数就是轻儿子的子树大小之和, 而这个值是不会超过 $O(n2 \log{n2})$ 的. CircleDescription 平面上有 $n$ 个点, 求有多少个无序三元组 $(i, j, k)$ 满足点 $i$, $j$, $k$ 确定的圆经过坐标原点. $n \le 2000$ Solution西姆松定理: 三个点确定的圆上任选一点向这三个点构成的三角形三边所在直线分别作垂线, 垂足三点共线. 证明可参考下图: 于是问题转化为求三点共线的数量. TriangleDescription 有一棵 $n$ 个点的树, 初始时树上没有石子, 可以进行若干次如下操作: 如果点 $u$ 的所有子树 $v$ 上都恰好有 $w_v$ 颗石子, 则可以从手中拿出 $w_u$ 颗石子放在点 $u$ 上. 将某个结点上的所有石子收回手中. 现在询问你对于每一个点 $i$, 要使得 $i$ 上恰好放有 $w_i$ 颗石子, 初始时手中至少需要多少颗石子. $n \le 10^5, w_i \le 10^9$ Solution首先可以发现操作的过程类似一个拓扑排序, 填上一个结点的石子之前先要将它的所有儿子都填上石子, 接着会立即收回儿子结点上的石子. 不妨反过来考虑, 定义一次操作为选择一个放有石子的点, 将它的儿子结点全部放上石子, 然后收回这个点的石子. 由于只需要考虑操作过程中石子数量的最大值, 可以发现反转顺序并不会影响答案. 用一个二元组 $(a, b)$ 描述一次操作, $a$, $b$ 分别表示在操作的过程中石子的总变化量和变化最大值, 注意到两个操作可以方便地合并: (a, b) + (c, d) = (a + c, \max\{b, a + d\})接下来考虑二元组 $X = (a, b)$ 和 $Y = (c, d)$ 之间的优先级, 不难得到以下优先级规则: $a \times c &lt; 0$ 时, 总变化量小于 $0$ 的二元组优先级更高. $a &lt; 0 ,\,\, c &lt; 0$ 时, 变化最大值较小的二元组优先级更高. $a &gt; 0 ,\,\, c &gt; 0$ 时, 总变化量减去变化最大值较小的二元组优先级更高. 以上规则也可利用交换法证明正确性. 又因为任意两个二元组合并得到的新二元组不会比原来的两个二元组都更优, 所以全局最优的二元组在可以选择的时候一定会马上选择, 于是得到一个贪心策略, 每次选择最优的二元组并将其和父亲当前对应的二元组进行合并, 可以发现这样能够得到整棵树的操作序列.]]></content>
      <tags>
        <tag>Summary</tag>
        <tag>Combinatorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展埃氏筛法小结]]></title>
    <url>%2F2018%2Fex-eratos-sieve%2F</url>
    <content type="text"><![CDATA[学完洲阁筛之后忘得差不多了, 不过现在已经可以将洲阁筛扔进垃圾桶了… Description求: h(n) = \sum_{i=1}^{n} f(i)其中 $f$ 是定义在正整数集下的积性函数, 满足 $f(p^c)$ 能够快速计算. Conversion首先可以将所有要求的数按照是否只含大于 $\sqrt{n}$ 的质因子分为两类, 对于第一类数一定是一个质数, 而第二类数一定可以在某个较小的质因子处考虑到, 于是我们只关注不超过 $\sqrt{n}$ 的那些质因子. 定义 $S_k(n, i)$ 表示小于等于 $n$ 的数中与前 $i$ 个质数互质的所有数与所有质数的 $k$ 次方和, 容易得到转移: S_k(n, i) = \begin{cases} S_k(n, i-1) & n < p_i^2 \\ S_k(n, i-1) - p_i^k \times \left(S_k(\left \lfloor \frac{n}{p_i} \right \rfloor, i - 1) - S_k(p_{i-1}, i - 1)\right) & \mathrm{otherwise} \end{cases}在考虑完 $\sqrt{n}$ 以内的所有质因数后, $S_k(n)$ 中留下了所有质数的 $k$ 次方, 这样所有第一类数的函数值都可以快速计算. 类似地, 定义 $G(n, i)$ 表示小于等于 $n$ 的数中仅由第 $i$ 个以后的质数构成的数与所有质数 $x$ 的 $f(x)$ 之和, 转移的方式类似: G(n, i) = G(n, i+1) + \sum_{c=0}^{\substack{p_i^{c+1} \le n}} f(p_i^{c+1}) + f(p_i^c) \times \left(G(\left \lfloor \frac{n}{p_i^c} \right \rfloor, i+1) - G(p_i, i+1)\right)复杂度约为 $O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566namespace SIV &#123; const int M = 100000; ll n; int m; uint val[M + 5]; int prime[M + 5], pcnt; uint s[M + 5], S[M + 5]; uint f[M + 5], F[M + 5]; inline uint gets(ll x) &#123; return x &lt;= m ? s[x] : S[n / x]; &#125; inline uint getf(ll x) &#123; return x &lt;= m ? f[x] : F[n / x]; &#125; int my_sqrt(ll x) &#123; int r = 1; while(1ll * (r + 1) * (r + 1) &lt;= x) ++ r; return r; &#125; void init(ll _n) &#123; m = my_sqrt(n = _n); for(int i = 1; i &lt;= m; ++i) &#123; val[i] = 81 * i * i - 27 * i + 9; s[i] = i - 1; S[i] = (n / i) - 1; &#125; for(int p = 2; p &lt;= m; ++p) &#123; if(s[p] == s[p-1]) continue; prime[pcnt ++] = p; const uint _s = s[p - 1]; const ll q = 1ll * p * p, lim = min((ll) m, n / q), x = m / p, y = n / p; for(int i = 1; i &lt;= x; ++i) S[i] -= S[i * p] - _s; for(int i = x + 1; i &lt;= lim; ++i) S[i] -= s[y / i] - _s; for(int i = m; i &gt;= q; --i) s[i] -= s[i / p] - _s; &#125; for(int i = 1; i &lt;= m; ++i) &#123; f[i] = s[i] * 63; F[i] = S[i] * 63; &#125; for(int e = pcnt; e &gt;= 1; --e) &#123; int p = prime[e-1]; const ll q = 1ll * p * p, lim = min((ll) m, n / q); for(int i = 1; i &lt;= lim; ++i) &#123; ll cur = n / i; for(ll t = p, c = 1; t * p &lt;= cur; t *= p, ++ c) &#123; F[i] += (getf(cur / t) - e * 63) * val[c] + val[c + 1]; &#125; &#125; for(int i = m; i &gt;= q; --i) &#123; int cur = i; for(int t = p, c = 1; t &lt;= cur / p; t *= p, ++ c) &#123; f[i] += (getf(cur / t) - e * 63) * val[c] + val[c + 1]; &#125; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记NOI2018]]></title>
    <url>%2F2018%2Fnoi2018%2F</url>
    <content type="text"><![CDATA[折腾了好久终于把博客修好了, 来填一些坑. Day -1上午在家无所事事, 收了下行李, 下午就到洋湖报到去了, 然后听说笔试时间调整到了上午, 感觉有点慌整个晚上都在背笔试. Day 0上午考笔试, 比预料中的简单很多, 没有什么快捷键之类的坑题也没有挂分, 试机就打了一个最简单的配置就跑了. 下午找了一间教室自习, 不知道干什么, 晚上懒得复习什么早早地睡了, 奇怪的是居然丝毫不紧张. Day 1第一试, 看了看题, 觉得题意都挺好理解的, 难度也基本按照题目顺序. 就直接开始写T1了, 写完 $\log^2$ 过了大样例直接丢到一边了, 然后看T2, 推了一个看起来有理有据的结论, 但不是很会算答案搞了很久大样例四个全错, 想了一下随便打了个特判过了其中两个, 又改了一下特判才在考试一半时间的时候过了大样例. 期间去上了一个厕所, 用掉20min… 看T3惊喜地发现68分特别傻逼, 飞快地码完过了大样例还有一个半小时, 正准备回去继续做T2最后20分的时候发现T1可能跑不过, 卡了很久的常, 期间竟然检查出好多致命的错误, 然后心里特别虚地不停检查, T2也没有继续想了. 好在最后并没有挂分. Day 1.5鸽了社会活动, 在自习室搞了一天颓. 直接打出了防沉迷警告… Day 2看完题目一直在想哪道题最简单, 然后T1补充了一个条件… 用了两个小时都没有从T1的倒数第二步推出最后一步, 想想当时可能真的受到了降智打击, 还自信地觉得T2比较可做, 码了很久发现是假算法, 感觉很慌滚去写T3暴力, 回来想先写T2的45分又不想放弃T1, 最后连T2的45分都没拿到… 感觉心态真的崩的厉害, 虽然最后查分发现意外的多了5分(大雾). 总结好像从去年NOIP以来, 身上一直有某种二试Debuff存在, 可能经常性的因为第一试考得不错, 而对多数情况下更难的二试心存轻视, 也没能调整好自己的心态吧. 不管怎样, 接下来的OI生涯, 要更加珍惜!]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平面树计数]]></title>
    <url>%2F2017%2Fcount-plane-tree%2F</url>
    <content type="text"><![CDATA[不常见的经典问题, 顺便总结一下Burnside引理吧. 问题描述 给定 $N$, 求 $N$ 个点的本质不同的平面树的数量.两棵平面树是等价的当且仅当其中一棵能够移动点的位置与另一棵重合, 且过程中仍然是一棵平面树. 做法考虑模型转化(计算 $N+1$ 个点的答案):取单位圆, 等距地取 $2N$ 个点, 然后将这些点两两配对连边, 满足所有连边不相交.发现它的对偶图恰好是一棵平面树, 像这样: 那么就只需要考虑本质不同的这样的配对的数量即可.两个圆是等价的当且仅当一个圆可以通过旋转一定的角度与另一个圆重合.而在这个圆上共有 $2N$ 个点, 就意味着有 $2N$ 个置换, 构成一个置换群. 置换群下的计数可以用到 Burnside引理 : N(G, C) = \frac{1}{|G|} { \sum_{f \in G} c(f) } 则转化为求置换下的不动点的数量: 不存在置换的情况下, 答案为 $C_N$, $\mathrm{Catalan}$ 数的第 $N$ 项.即将相互匹配的位置看作左右括号, 则所有合法的括号序列都对应一个满足条件的圆. $N$ 为奇数时, 可能存在一条平分圆的对角线在置换下不变, 计算 $\frac{N+1}{2}$ 个点的答案即可. 考虑旋转置换.为了满足旋转之后的边重合, 点 $i$ 和它的匹配点 $p_i$ 在旋转后应该仍然是相匹配的.则环的数量一定是偶数 $2d$, 所以环的长度可以表示为 $\frac{2N}{2d} = \frac{N}{d}$. 假定置换的阶是 $e$, $e &gt; 1, e | N$, 环的数量 $2d = \frac{2N}{e}$.环上与 $0$ 匹配的点为 $i$, 不难发现在这些点之间的点的方案数为 $C_{i-1}$.当这些点确定之后, 它们在环上依次经过的 $e(i+1)$ 个点就确定了. 令 $f(x)$ 表示 $\mathrm{Catalan}$ 数的生成函数, 根据 $\mathrm{Catalan}$ 数的递推式, 不难得到: f(x) = xf^2(x) + 1构造 $B_d$ 表示包含 $2d$ 个环的置换下不动点的数量. B_d = 2\sum_{i = 0}^{d-1} C_i B_{d-i-1}其中因子 $2$ 考虑的是 $i &gt; 2d$ 时用当前置换的逆来计算的情况. 则 $B_d$ 的生成函数 $g(x)$ 满足: g(x) = 2x g(x) f(x) + 1解得: g(x) = (1 - 4x) ^ {-\frac{1}{2}}问题解决p(n) = \frac{1}{2n} ( [\mathrm{n \, is \, odd}]\binom{n}{\lfloor\frac{n}{2}\rfloor} - \binom{2n}{n-1} + \sum_{d|n}{\varphi(n/d)\binom {2d}{d}} )]]></content>
      <tags>
        <tag>Combinatorial</tag>
        <tag>Generating Function</tag>
        <tag>Burnside</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在NOIP2017之后]]></title>
    <url>%2F2017%2Fafter-noip-2017%2F</url>
    <content type="text"><![CDATA[引 本来应该有另一篇博客叫做写在NOIP2017之前的, 但跑回家才意识到博客搭在机房的电脑上, 于是…… 比赛过程Day1看到这个T1不送分了, 心里还是有点虚, 认真地读完了后面两题平复了一下心态.想着既然是T1, 肯定不是送就是偷, 看着样例找了找规律, 推了个 $ a + b + (b \% a) (a &lt; b) $ 的方法, 发现过不了大样例. 于是盯着大样例发呆, 突然发现了世界的奥秘.然后写T2, 写完眼查了一下大样例, 正要关闭窗口的时候 Vimdiff 了一波, 发现自己大小写写错一大堆…T3想了想写了个不考虑零边的记忆化搜索, 发现大样例过不了 认真思考了一下发现是没有考虑到达终点又折返的情况 又想了想发现 $-1$ 挺好判的, 就加上了. Day2到达考场时精神状态不太好, 意识模糊地打开了题目.看完T2一直在想MST什么的, 感觉不太会做准备放弃时发现数据范围只有12, 于是秒懂了.T3没想多久推出一个平衡树的做法, 对自己代码能力过于自信没有多想就开始写, 结果调到最后一刻还是GG了. 反思错误感觉这次虽然题目比较奇怪, 但实际难度还是合理的, 出现了一些失误恰恰暴露出身上的一些问题. 考试的时候大部分处在一种边想边写的状态, 一边写可能还要一边完善一些细节. 刷了很多Atcoder 的题目之后, 代码能力退化明显. 考场的debuff比较强. 可能后面两条还稍微可以接受吧, 但是第一条的确是硬伤, 这样做简单题或者在比较清醒的时候写题可能还好, 然而一旦遇到代码实现比较复杂或者条件比较多的题目, 就会挂得很惨, 这个问题模拟赛中也出现过几次.解决的策略其实说起来也不难, 主要就是每道题写之前把算法细节考虑基本清楚, 做到 $ Think \,\, twice, Code \,\, once $ 吧. 这样也不会出现某道题写了很久最后发现做法是错误的这种尴尬的情况也能够避免写一些特别复杂的做法. 关于未来针对这次联赛的问题和原来的一些弱点, 对接下来的一段学习做一些规划： 补一些数学相关的知识（不一定OI相关） 提高一下代码能力, 复习一些不熟练的数据结构, 刷一些质量比较高的题目 然后的话, 回去就要补文化了吧.]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC2017 游戏]]></title>
    <url>%2F2017%2Fctsc2017-game%2F</url>
    <content type="text"><![CDATA[Description 有$N$ 局游戏, 除第一局游戏外每一局游戏的获胜机率均与上一局游戏的结果有关. 现在对游戏进行$Q$次修改, 每次告诉你某一局游戏的结果或者删除之前给你的信息, 求修改后期望下获胜的场数为多少. $ N, Q \le 2 \times 10 ^ 5 $ Solution首先不难发现, 某一局的游戏的胜率只与其左右的最近游戏结果相关, 所以答案可以分段计算. 考虑期望的线性性, 可以将期望胜利场数表示成每一局游戏的胜率之和.记 $X _ i$ 表示第$i$ 场游戏的状态. 所求即为 $ \sum _ {l &lt; m &lt; r} P( X _ m = 1 | X _ l, X _ r) $. 由贝叶斯公式: \begin{align} P(X _ m = 1 | X _ l, X _ r) &= \frac{P(X _ m = 1, X _ l, X _ r)}{P(X _ l) \cdot P(X _ r | X _ l) } \\ &= \frac{P(X _ l) \cdot P(X _ m = 1 | X _ l) \cdot P(X _ r | X _ l, X _ m = 1)}{P(X _ l) \cdot P(X _ r | X _ l)} \\ &= \frac{P(X _ m=1 | X _ l) \cdot P(X _ r | X _ l, X _ m = 1)}{P(X _ r | X _ l)} \\ &= \frac{P(X _ m=1 | X _ l) \cdot P(X _ r | X _ m = 1)}{P(X _ r | X _ l)} \end{align}发现分母是常数, 于是可以合并分子.考虑分子的意义, 大概是合法状态下当前位置为胜的概率.每一段就可以直接用$dp$来处理出答案, 记录某场比赛为胜/ 负的概率以及分子的期望即可.这个复杂度是每次询问$O(n)$的. 其实这道题要讲的已经讲完了, 最后只要用矩乘快速合并$dp$值, 维护一下就可以了.]]></content>
      <tags>
        <tag>Probability</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两道概率题]]></title>
    <url>%2F2017%2Fprobability-problems%2F</url>
    <content type="text"><![CDATA[玛里苟斯Description 给你一个大小为N的可重集合, 求该集合子集异或和的$K$次方的期望, 保证答案不超过$2 ^ {64}$. $N \le 100000, K \le 5, A _ i \le 10 ^ 9$ Solution&emsp;&emsp; $K=1$ 时满足期望的线性性, 可以对每一个二进制位分开计算答案. 不难发现每一个二进制位变成 $1$ 的概率恰好为 $\frac {1}{2}$ (集合的奇数和偶数大小的子集数相同). &emsp;&emsp; $K=2$ 时要求的是期望的平方, 即: \sum_{i=0}^{32} \sum_{j=0}^{32} b_i b_j 2^{i+j}其中 $b_i$表示期望二进制第 $i$ 位的值, 枚举两个二进制位再求一下两个位置同时取到 $1$ 的概率即可. &emsp;&emsp; $K \ge 3$时由于答案不超过 $2^{64}$, 所以集合内的数也不会很大, 直接用线性基处理. 主旋律Description 求N个点, M条边的有向图有多少生成子图满足整个图是强联通的. $N \le 15, M \le N(N-1)$ Solution&emsp;&emsp; 这题一眼看上去不太好做, 不妨从问题的反面来考虑. 首先一个非强联通的图缩掉$Scc$ 之后会得到若干个 $DAG$. 如果知道$Scc$ 的划分情况, 计算$DAG$ 的数量就变成一个经典问题了: E(S, T) = {|\{(u, v) \in E | u \in S, v \in T)\}|}F(S) = \sum _ {T \subset S, T \neq \varnothing} (-1) ^ {|T| - 1} \times 2 ^ {E(T, S-T)} F(T)&emsp;&emsp; 然而感觉枚举$Scc$ 划分更不可做. 先不考虑$Scc$ 如何划分, 考虑哪一些点集构成多少个$Scc$. 假设$G _ K(T)$表示$T$ 集合分成$K$ 个$Scc$ 的方案数, 类似上面式子地, 有: F(S) = \sum _ {T \subset S, T \neq \varnothing} \sum _ {K = 1}^{|T|} (-1) ^ {K - 1} \times G _ K(T) \times 2 ^ {E(T, S-T) + E(S-T, S-T)}DP(S) = 2 ^ {E(S, S)} - F(S)&emsp;&emsp; 实际上只需要求将某个集合分成奇数个$Scc$ 与偶数个$Scc$ 的方案数之差 $P(S)$: P(S) = DP(S) + \sum _ {T \subset S, u \in T} - DP(T) \times P(S - T) 其中 $u \in T$ 避免重复计数. &emsp;&emsp; 这样加上一些预处理的技巧可以做到 $O(3 ^ n)$.]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Combinatorial</tag>
        <tag>Probability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder 选做]]></title>
    <url>%2F2017%2Fatcoder-select%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 其实是总结一下比赛中遇到的好题, 然后瞎做了几场 AGC 的题目练习, 感觉还比较有意思. AGCAGC002 F Leftmost Ball 给你$N$种不同颜色的球, 每种有$K$个, 现在你可以将球任意排列, 但最终的序列中每种颜色的第一个出现位置要被染成$0$颜色, 求能够得到的本质不同的序列数, 对$10^9 + 7$取模. $N, K \leq 2000$ &emsp;&emsp; 这题正着处理没有什么思路, 但是如果从右往左来会比较好考虑. 我们可以记$f(i, j)$表示当前从右往左填剩下$i$个$0$颜色的球, 还剩下$j$种颜色没有放的方案数. 那么每一次的决策就包括放入一个$0$颜色的球以及添加一种颜色的$k-1$个球: \begin{aligned} f(i-1, j) & \leftarrow f(i, j) \mid [i > j] \\ f(i, j-1) & \leftarrow f(i, j) \times {n-i + (n-j) \times (k-1) + k-2 \choose k-2} \end{aligned} 后面那个公式是可重集, 还有最后的答案要乘以$n!$. AGC005 D ~K Perm Counting 求长度为$N$的排列中, 满足对任意的$i$, 都有$|a_i - i| \neq K$的排列数量. $1 \leq K &lt; N \leq 2000$ &emsp;&emsp; 考虑容斥, 计算至少有$i$个位置不合法的方案数. 由于$K$是确定的, 那么所有不合法的方案可以看成是完全二分图匹配中出现了一条$(i, i+k)$的边或者一条$(i, i-k)$的边. &emsp;&emsp; 将这样的边在画出来就是若干条交叉路径. 观察到这样的交叉路径不相交, 所以可以拆开拼成一个序列, 然后在序列上$dp$即可. AGC015 D A or…or B Problem 求在$[A, B]$中任意选出一个非空整数集合的元素位或和有多少种不同的答案. $1 \le A \le B \le 2^{60}$ &emsp;&emsp; 先考虑一些比较特殊的情况(以下默认$A, B$的位数相同): 当$B$可以表示为$2^k - 1$时, 这个位或和恰好取遍$[A, B]$之间的所有整数. 当$A$可以表示为$2^k$时, 这个位或和在区间$[A, A + 2^{t+1}) \mid t &lt; log_2 A$中, 其中$t$是最大的满足$B$的第$t$位为$1$的数. &emsp;&emsp; 那么一般情况下这些条件有什么用呢? &emsp;&emsp; 我们考虑找到最大的一个$T$,使得$B$的第$T$位为$1$且$A$的第$T$位不为$1$, 记$K = 2 ^ T$. 当选择的数的集合在$[A, K)$以及在$[K, B]$中的情况可以直接用上述结论. &emsp;&emsp; 接下来考虑同时选取两个集合中的数可能会产生的答案. 因为这时小于$K$的部分是没有贡献的, 所以直接将$[A, K)$中的所有答案取出. 不难发现$[K, B]$中取任意个都与只使用$K$没有区别, 那么这时候的范围是$[K+A, 2\times K-1]$, 注意减去重复贡献. AGC015 F Kenus the Ancient Greek Q组询问, 每组询问的形式为A, B, 表示求$x \in [1, A], y \in [1, B]$的$g(x, y)$的最大值, 及最大值的方案数, 其中: g(x, y) = \begin{cases} 1, & \text{y = 0} \\ g(y, x), & \text{x > y} \\ g(y \; mod \; x, x) + 1, & \text{otherwise} \\ \end{cases}$1 \le Q \le 3 \times 10 ^ 5 \,\,, 1 \le A, B \le 10 ^ {18}$ &emsp;&emsp; 以下无特殊说明, 均默认所有$x &lt; y, A &lt; B$&emsp;&emsp; 先考虑第一问, 如果我们由一个特定的$(x, y)$, 从小到大地构造使得$g(x, y)$的值不断地变大, 那么如何构造使得这个值最大呢?&emsp;&emsp; 对于所有$(x’, y’)$满足$g(x’, y’) = g(x, y) + 1$, 显然有: (x', y') \in \{ (y, x + ky) \mid k \in Z^+ \}&emsp;&emsp; 同时, 为了使得这个过程尽可能的多次进行,我们从$(0, 1)$出发, 每次取$k = 1$.发现这样生成了一组$Fibonacci$数列, 这里$Fibonacci$数列从0开始标号.&emsp;&emsp; 那么第一问的答案就是求满足$Fib_k \le A,\; Fib_{k+1} \le B$的最大的$k$. 同时, 这样的数对是满足$g(x, y) = k$的最小的数对.&emsp;&emsp; 接下来考虑统计方案数. 首先, 对于一组询问我们只需考虑其中与最优解相关的$(x, y)$.&emsp;&emsp; 考虑所有最优的$(x, y)$会具有的性质: $x \ge Fib_k, \; y \ge Fib_{k+1}$ 不存在一组$(x’ &lt; x, y’ &lt; y)$, 使得$g(x’, y’) &gt; g(x, y)$ &emsp;&emsp; 然而这样的$(x, y)$并不一定是最优的.&emsp;&emsp; 我们接着分析所有在最优解的$g$的计算路径上的数对$(x, y)$的性质: 不难发现, 经过一次变化后得到的$(x’, y’)$, 一定满足: $g(x’, y’) = k-1$ $x’ \ge Fib_{k-1}, y’ \ge Fib_{k}$ $y’ \le Fib_{k+1} + Fib_{k-2}$ &emsp;&emsp; 后面条件的解释: 若$y’ &gt; Fib_{k+1} + Fib_{k-2}$, 则: (x, y) = (y' > Fib_{k+1} + Fib_{k-2} > Fib_{k+1}, x' + py' \ge x' + y' > Fib_{k+2})&emsp;&emsp;$(x, y)$不再满足上述最优性质2, 矛盾.&emsp;&emsp; 同时每次向下一步进行构造的时候只有$(Fib_k, Fib_{k+1})$可能取到$p = 2$所以这样的数对个数是$O(k)$的. 所以我们预处理所有的这样的数对, 然后用除法算下答案就好了.&emsp;&emsp; 复杂度$O(log^2{MAX} + QlogMAX)$. ARCARC 的题目主要来源是打过的几场比赛, 暂时不多. ARC074 E RGB Sequence 给你一个长度为$N$的序列和$M$组约束条件, 每组条件形如$L_i, R_i, X_i$, 表示序列上的$[L_i, R_i]$中恰好有$X_i$种颜色, 现在要你用三种颜色给这个序列染色, 求满足所有约束的方案数. $1 \le N, M \le 300$ &emsp;&emsp; $dp$的思路应该比较显然, 然而普通的状态表示不太好处理. 我们记$dp_{r, g, b}$表示三种颜色的球最后一次出现的位置分别是$r, g, b$时的方案数. &emsp;&emsp; 然后考虑状态的合法性, 可以把条件存在$R_i$的位置. 当选择一个状态时, 考虑这个状态的最末位的所有约束即可. ARC077 F SS 定义一个字符串为偶的, 当且仅当这个字符串能够被分成两个完全相同的字符串. &emsp;&emsp; 定义函数$f(s)$, 其中$s, f(s)$均是字符串,$f(s)$为在字符串$s$后添加非空的字符满足新串为偶且长度最小的串. 现在给你串$s$(初始为偶的), 求$f^{10^{100}}(s)[L, R]$中各个字母的出现次数.$1 \le |S| \le 2\times 10^5$$1 \le L \le R \le 10^{18}$ &emsp;&emsp; 首先对于一个给定的$s$, 其$f(s)$必定唯一. 考虑每次最少加一个字符,$f^{10^{100}}(s)$就等价于一个长度无穷的字符串. 这个答案的形式显然可以前缀和, 又因为$s$在变化过程中始终是偶的, 实际上我们只需要关注左半部分的字符. &emsp;&emsp; 我们从最简单的一次操作来考虑. 记初始的字符串$s$为$SS$, 记一次变化之后左边的部分为$ST$, 那么得到的新串就是$STST$. 要使得加的字符长度最小, 就要在$S$中找到最长前后缀匹配长度, 这时$T$就是$S$去掉最长匹配后缀所得. &emsp;&emsp; 我们发现, 每次操作都等价于找到前后缀匹配最大长度(当然要小于$|S|$), 然后将剩下部分的前缀$T$添加到$S$的末尾. 当$|T| \mid |S|$时,$|S|$有长为$|T|$的最小周期, 每次加入的$|T|$相同. 当$|T| \nmid|S|$时, 我们通过打表发现, 这样的$T$是在有规律地变化的, 因为每次加入$T$之后的串前后缀最长匹配一定是$|T|$, 否则的话, 上一步中最长匹配的性质就不一定会满足. &emsp;&emsp; 然后我们得到了一个$Fibonacci$数列? 直接暴力算就好了… 实际上第一种情况也可以直接算, 因为整个序列都是$T$的若干次重复得到的.]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Summary</tag>
        <tag>Combinatorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Div2 418E]]></title>
    <url>%2F2017%2Fcf-418e%2F</url>
    <content type="text"><![CDATA[Description 求满足如下条件的 $N$ 个点的简单无向图的个数对 $ 1e9 + 7 $ 取模的结果： 每个点的度数均为 $2$ 或 $3$ 从一号点到任何一个点的最短路唯一并且随着点标号上升而不降. (两个图不同当且仅当边的集合不同).$N &lt;= 50$ Solution我们可以记: $f_{i, j}$ 表示考虑完前 $i$ 个点, 最后一层恰好有 $j$ 个点, 且最后一层之前的点度数已经满足条件时的方案数. $g_{i, j, k}$ 表示当前层有 $i$ 个点, 上一层剩下来 $j$ 个度为 $2$ 的点, $k$ 个度为 $3$ 的点时连边的方案数. 那么容易得到$f_{i, j} = \sum_{k} f_{i-j, k} \times g_{j, c0, c1}$, 其中$c0\,,c1$表示最后一层 $k$ 个点中度为 $2$ 的点和度为 $3$ 的点的个数. 对于 $g$, 不难得到: g_{i, j, k} = \begin{cases} 1 & i = 0, j = 0, k = 0 \\ \sum_{l=2}^{k-1} \frac{l!}{2} {k-1 \choose l} g_{i, j, k-l-1} & i = 0, j = 0, k > 0 \\ (j-1) \cdot g_{i, j-2, k} + k \cdot g_{i, j, k-1} & i = 0, j > 0 \\ j \cdot g_{i-1, j-1, k} + k \cdot g_{i-1, j+1, k-1} & i > 0 \end{cases}Hint注意在第二个递推式中 $l$ 从 $2$ 开始枚举, 因为不能有重边, 所以不存在大小为 $2$ 的环.]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Combinatorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2017 树状数组]]></title>
    <url>%2F2017%2Fzjoi2017-bit%2F</url>
    <content type="text"><![CDATA[Description 给你一个长度为 $N$ 的序列以及 $M$ 次操作, 每次等概率地修改 $[L_i, R_i]$ 区间中一个值的奇偶性, 或者对于询问$[L_i,R_i]$区间中的和的奇偶性, 判断给定的一种错误算法输出正确答案的概率是多少$ N, M &lt;= 10^5 $ Solution考虑这个错误算法, 由于可以把 $ + lowbit $ 和 $ - lowbit $ 都看成在一棵树上向父亲节点跳, 根据这个性质可以知道错误算法求了一个后缀和, 所以当且仅当对于询问区间 $[L_i, R_i]$, 满足 $ a[L_i-1] = a[R_i] $ 时它会输出正确答案 那么我们得到了一个 $ O(nm) $ 的暴力算法, 即每一个询问都暴力扫之前的所有修改计算概率即可. 然而这样还不能通过所有数据, 考虑将区间 $[L_i, R_i]$ 表示成二维平面上的一个点 $ (L_i, R_i)$. 然后用一个二维线段树去维护每个点代表的两个端点的值不相等的概率.显然地, 这个概率是可以很方便的合并的.这样对于每次修改$[L_i, R_i]$的操作, 相当于: 将 $ x \in [L_i, R_i], y \in [L_i, R_i] $ 中的点 $(x, y)$ 与 $ \frac{2}{R_i - L_i+1} $ 合并. 将 $ x \in [L_i, R_i], y \in (R_i, N] $ 以及 $ x \in [0, L_i), y \in [L_i, R_i] $ 与 $ \frac{1}{R_i - L_i+1} $ 合并. Hint注意到对于 $ L_i = 1 $ 的情况, $ Find(0) $ 直接返回了 $0$ 而非 $0$ 的后缀和这个时候就要特判一下了, 注意到每次不管如何修改, 最终的正确答案是 $R_i$ 的前缀和, 而题中所给的方法输出的答案是 $R_i$ 的后缀和. 当前修改次数为偶数, 则当且仅当 $R_i = 0$ 前后缀和相同, 相当于查询 $a[R_i] = 0$ 的概率. 当前修改次数为奇数, 则当且仅当 $R_i = 1$ 前后缀和相同, 相当于查询 $a[R_i] = 1$ 的概率. 因为 $a[0]$ 不可能被修改, 所以上述问题也可以转化为查询 $[L_i, R_i]$ 相等概率. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define fst first#define snd second#define pb push_back#define getchar getchar_unlockedtemplate &lt;typename T&gt; inline bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template &lt;typename T&gt; inline bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;const int oo = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int mod = 998244353;int read() &#123; int n = 0, f = 1; char ch = getchar(); for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1; for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; return n * f;&#125;inline int merge(int a, int b) &#123; return (a * (1LL - b + mod) % mod + b * (1LL - a + mod) % mod) % mod;&#125;int N, M, prob;namespace Seg_Tree &#123; const int SZ_X = (maxn &lt;&lt; 2) + 5; const int SZ_Y = (maxn * 400) + 5; int rt[SZ_X]; int val[SZ_Y]; int lc[SZ_Y], rc[SZ_Y], cnt;#define LC (u &lt;&lt; 1) #define RC (LC | 1)#define mid ((l+r) &gt;&gt; 1) void Add_Y(int&amp; u, int l, int r, int x, int y) &#123; if(!u) u = ++cnt; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; val[u] = merge(val[u], prob); return; &#125; if(x &lt;= mid) Add_Y(lc[u], l, mid, x, y); if(y &gt; mid) Add_Y(rc[u], mid+1, r, x, y); &#125; void Add_X(int u, int l, int r, int x, int y, int x0, int y0) &#123; if(x &lt;= l &amp;&amp; r &lt;= y) &#123; Add_Y(rt[u], 0, N, x0, y0); return; &#125; if(x &lt;= mid) Add_X(LC, l, mid, x, y, x0, y0); if(y &gt; mid) Add_X(RC, mid+1, r, x, y, x0, y0); &#125; int query_Y(int u, int l, int r, int x) &#123; if(l == r) return val[u]; return merge(val[u], x &lt;= mid ? query_Y(lc[u], l, mid, x) : query_Y(rc[u], mid+1, r, x)); &#125; int query_X(int u, int l, int r, int x, int x0) &#123; if(l == r) return query_Y(rt[u], 0, N, x0); return merge(query_Y(rt[u], 0, N, x0), x &lt;= mid ? query_X(LC, l, mid, x, x0) : query_X(RC, mid+1, r, x, x0)); &#125;&#125;int fpm(int base, int exp) &#123; int res = 1; for(; exp &gt; 0; exp &gt;&gt;= 1) &#123; if(exp &amp; 1) res = 1LL * res * base % mod; base = 1LL * base * base % mod; &#125; return res;&#125;int tot = 0;void solve() &#123; N = read(); M = read(); while(M--) &#123; static int ty, l, r; ty = read(); l = read(); r = read(); if(ty == 1) &#123; static LL tmp; tmp = fpm(r-l+1, mod-2); prob = 2*tmp; Seg_Tree::Add_X(1, 0, N, l, r, l, r); prob = tmp; Seg_Tree::Add_X(1, 0, N, l, r, r+1, N); prob = tmp; Seg_Tree::Add_X(1, 0, N, 0, l-1, l, r); ++ tot; &#125;else &#123; static int ans; ans = (1-Seg_Tree::query_X(1, 0, N, l-1, r)+mod) % mod; if(!(l-1) &amp;&amp; (tot &amp; 1)) ans = (1-ans+mod) % mod; printf("%d\n", ans); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif solve(); return 0;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2016 网格]]></title>
    <url>%2F2017%2Fnoi2016-grid%2F</url>
    <content type="text"><![CDATA[Description 给出一个 $ N \times M $ 的网格图和图上的 $ C $ 个障碍物, 求最少删去多少个点可使得原图空格不四连通.$ N, M &lt;= 10 ^ 9, C &lt;= 10 ^ 5 $ Solution我们可以发现, 可能的答案只有 $ \{ -1, 0, 1, 2 \} $ 几种. 考虑一些简单的情况:答案等于 $ -1 $ 时, 点数小于 $2$ 或者恰好有两个相邻的点.答案为 $ 0 $ 时, 显然原图不连通. 那么就只需知道答案是否为 $ 1 $, 发现答案等于 $ 1 $ 当且仅当原图存在割点, 暴力的话不难做到 $ O(n * m) $. 将到达每个障碍的曼哈顿距离不超过 $2$ 的空格给提出来, 然后在这些点中找出一个割点, 满足到达最近的障碍的距离不超过 $1$.这样的点就一定是原图中的割点. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;#define fst first#define snd second#define pb push_backtemplate &lt;typename T&gt; bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template &lt;typename T&gt; bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;const int maxn = 2.5e6 + 10;const int oo = 0x3f3f3f3f;template&lt;typename T&gt; T read() &#123; T n = 0, f = 1; char ch = getchar(); for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1; for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; return n * f;&#125;struct Hash_Map &#123; static const int mod = 1666667; int cnt = 0; int st[mod], nxt[maxn], X[maxn], Y[maxn]; inline void clear() &#123; cnt = 0; memset(st, 0, sizeof st); &#125; inline int idx(int x, int y) &#123; return ((233LL*x + (y^888))%mod + mod)%mod; &#125; int find(int x, int y) &#123; int u = idx(x, y); for(int i = st[u]; i; i = nxt[i]) if(X[i] == x &amp;&amp; Y[i] == y) return i; return -1; &#125; int insert(int x, int y) &#123; int u = idx(x, y); for(int i = st[u]; i; i = nxt[i]) if(X[i] == x &amp;&amp; Y[i] == y) return i; ++ cnt; X[cnt] = x, Y[cnt] = y; nxt[cnt] = st[u]; st[u] = cnt; return cnt; &#125;&#125;HM;LL n, m, c;const int dx[] = &#123; 0, 1, 0, -1, 1, -1, 1, -1 &#125;;const int dy[] = &#123; 1, 0, -1, 0, 1, -1, -1, 1 &#125;;int st[maxn], nxt[maxn &lt;&lt; 3], to[maxn &lt;&lt; 3], ecnt = 1;void addedge(int x, int y) &#123; to[++ecnt] = y; nxt[ecnt] = st[x]; st[x] = ecnt; to[++ecnt] = x; nxt[ecnt] = st[y]; st[y] = ecnt;&#125;int vis[maxn];int mark[maxn], now = 0;void init() &#123; ecnt = 1; HM.clear(); memset(st, 0, sizeof st);&#125;int flood_fill(int u) &#123; int res = 1; mark[u] = now; for(int i = st[u], v; i; i = nxt[i]) if(mark[v = to[i]] != now) res += flood_fill(v); return res;&#125;int area_count(int s) &#123; return ++ now, flood_fill(s); &#125;int chk() &#123; if(n*m-c &lt; 2) return -1; int res = area_count(c + 1); if(n*m == 2 || (res == 2 &amp;&amp; n*m-c == 2)) return -1; return -2;&#125;bool flag;int dfn[maxn], low[maxn], dfs_clock = 0;bool dfs(int u, int fa, bool f = false) &#123; low[u] = dfn[u] = ++dfs_clock; for(int i = st[u], v; i; i = nxt[i]) if((v = to[i]) ^ fa) &#123; if(!dfn[v]) &#123; if(dfs(v, u)) return true; if(vis[u] == 1 &amp;&amp; (low[v] &gt; dfn[u] || (!f &amp;&amp; low[v] == dfn[u]))) &#123; return true; &#125; chkmin(low[u], low[v]); &#125;else chkmin(low[u], dfn[v]); &#125;&#125;bool chk1() &#123; flag = 0; memset(dfn, dfs_clock = 0, sizeof dfn); for(int i = c+1; i &lt;= HM.cnt; i++) if(!dfn[i]) &#123; if(dfs(i, 0, 1)) return 1; &#125; return 0;&#125;#define x(i) HM.X[i]#define y(i) HM.Y[i]//char ch[1000][1000];int X[maxn], Y[maxn], idx[maxn];bool chk0() &#123; memset(idx, 0, sizeof idx); memset(vis, 0, sizeof vis); for(int i = 1; i &lt;= c; i++) HM.insert(X[i], Y[i]); for(int v = 1; v &lt;= c; v++) if(!vis[v]) &#123; vector&lt;int&gt; V; static int q[maxn]; int head = 0, tail = 0; ecnt = 1; vis[q[tail++] = v] = 3; while(head &lt; tail) &#123; int h = q[head++]; for(int i = 0; i &lt; 8; i++) &#123; int nx = x(h) + dx[i]; int ny = y(h) + dy[i]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.insert(nx, ny); st[Nxt] = 0; if(Nxt &lt;= c) &#123; if(!vis[Nxt]) &#123; vis[Nxt] = 3; q[tail++] = Nxt; &#125; &#125;else if(idx[Nxt] != v) &#123; idx[Nxt] = v, V.pb(Nxt); &#125; &#125; &#125; &#125; for(int i = 0; i &lt; int(V.size()); i++) &#123; int u = V[i]; for(int j = 0; j &lt; 2; j++) &#123; int nx = x(u) + dx[j]; int ny = y(u) + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.find(nx, ny); if(idx[Nxt] == v) addedge(u, Nxt); &#125; &#125; &#125; if(V.size() &amp;&amp; area_count(V[0]) != int(V.size())) return true; &#125; return false;&#125;void build() &#123; memset(vis, 0, sizeof vis); int tail = 0; static int q[maxn]; for(int i = 1; i &lt;= c; i++) HM.insert(X[i], Y[i]), vis[i] = 3; for(int i = 1; i &lt;= c; i++) for(int j = 0; j &lt; 8; j++) &#123; int nx = X[i] + dx[j]; int ny = Y[i] + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.insert(nx, ny); if(!vis[Nxt]) &#123; vis[Nxt] = 1; q[tail++] = Nxt; &#125; &#125; &#125; int lim = tail; for(int i = 0; i &lt; lim; i++) &#123; for(int j = 0; j &lt; 8; j++) &#123; int nx = x(q[i]) + dx[j]; int ny = y(q[i]) + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.insert(nx, ny); if(!vis[Nxt]) &#123; vis[Nxt] = 2; q[tail++] = Nxt; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; tail; i++) &#123; for(int j = 0; j &lt; 2; j++) &#123; int nx = x(q[i]) + dx[j]; int ny = y(q[i]) + dy[j]; if(nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m) &#123; int Nxt = HM.find(nx, ny); if(Nxt &gt; c) addedge(q[i], Nxt); &#125; &#125; &#125;&#125;int spe() &#123; int res = 0; if(n == 1) &#123; Y[++c] = 0; Y[++c] = m+1; sort(Y+1, Y+c+1); for(int i = 2; i &lt;= c; i++) if(Y[i] - Y[i-1] &gt; 1) ++ res; &#125;else &#123; X[++c] = 0; X[++c] = n+1; sort(X+1, X+c+1); for(int i = 2; i &lt;= c; i++) if(X[i] - X[i-1] &gt; 1) ++ res; &#125; return res &gt;= 2 ? 0 : 1;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif for(int T = read&lt;int&gt;(); T--; ) &#123; init(); n = read&lt;int&gt;(); m = read&lt;int&gt;(); c = read&lt;int&gt;(); for(int i = 1; i &lt;= c; i++) &#123; X[i] = read&lt;int&gt;(); Y[i] = read&lt;int&gt;(); &#125; if(chk0()) &#123; puts("0"); continue; &#125; init(); build(); static int ans; if((ans = chk()) != -2) &#123; &#125; else if(min(n, m) == 1) &#123; ans = spe(); &#125; else &#123; ans = chk1() ? 1 : 2; if(c == 0) ans = min(n, m) == 1 ? 1 : 2; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 553E Kyoya and Train]]></title>
    <url>%2F2017%2Fcf-553e%2F</url>
    <content type="text"><![CDATA[Description 给定 $N$ 个点, $M$ 条边的有向图.每条边有花费: 通过第 $i$ 条边的时间有 $ P _ {i1} $ 的概率为 $1$, $P _ {i2}$ 的概率为 $2$…如果总用时超过 $T$ 则会被罚钱 $X$ 元, 求从 $1$ 号点到 $n$ 号点的最小期望花费.$ N \leq 50, M \leq 100, T \leq 100000 $ Solution考虑暴力DP, 记状态 $ dp _ {i, t} $ 表示到达 $i$ 号点, 且经过的时间为 $t$ 的最小期望花费, 转移十分显然.同时因为状态之间按照时间构成一个拓扑图, 所以转移不存在环. 可以记 $S _ {e, t}$ 表示边 $e$ 在时刻 $t$ 之后后继状态的最小期望花费. 则可以用下面这个式子计算 $dp _ {e, t}$: dp _ {i, t} = min \left\{ S _ {e, t} + cost _ e \right\}$e$ 是 $i$ 的出边. 接下来考虑如何计算 $S(e,t)$, 利用定义: S _ {e, t} = \sum _ {i = 1}^{T} dp _ {to _ e, t + i} * P _ {ei}这样变成卷积形式, 分治 $FFT$ 即可. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; pii;const int oo = 0x3f3f3f3f;const int maxn = 200000 + 10;const double PI = acos(-1.0);template &lt;typename T&gt; bool chkmax(T&amp; a, T b) &#123; return a &lt; b ? a = b, 1 : 0; &#125;template &lt;typename T&gt; bool chkmin(T&amp; a, T b) &#123; return a &gt; b ? a = b, 1 : 0; &#125;#define fst first#define snd second#define debug(x) cerr &lt;&lt; #x &lt;&lt; ":" &lt;&lt; (x) &lt;&lt; endl#define REP(i, a, b) for(int i = (a), i##end = (b); i &lt; i##end; ++i)#define DREP(i, a, b) for(int i = (a)-1, i##bgn = (b); i &gt;= i##bgn; --i)template&lt;typename T&gt; T read() &#123; T n = 0, f = 1; char ch = getchar(); for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1; for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; return n * f;&#125;struct Complex &#123; double real, imag; Complex(double r = 0.0, double i = 0.0): real(r), imag(i) &#123;&#125; Complex operator + (const Complex&amp; rhs) const &#123; return Complex(real + rhs.real, imag + rhs.imag); &#125; Complex operator - (const Complex&amp; rhs) const &#123; return Complex(real - rhs.real, imag - rhs.imag); &#125; Complex operator * (const Complex&amp; rhs) const &#123; return Complex(real*rhs.real - imag*rhs.imag, real*rhs.imag + imag*rhs.real); &#125; Complex operator / (const double&amp; div) const &#123; return Complex(real / div, imag / div); &#125;&#125;;int rev[maxn];void DFT(Complex *x, int N, int t) &#123; for(int i = 0; i &lt; N; i++) if(i &lt; rev[i]) swap(x[i], x[rev[i]]); for(int l = 2; l &lt;= N; l &lt;&lt;= 1) &#123; Complex wn = Complex(cos(2*PI*t/l), sin(2*PI*t/l)); for(int i = 0; i &lt; N; i += l) &#123; Complex w = Complex(1, 0); for(int j = 0; j &lt; (l &gt;&gt; 1); j++, w = w * wn) &#123; Complex L = x[i + j]; Complex R = x[i + j + (l &gt;&gt; 1)] * w; x[i + j] = L + R; x[i + j + (l &gt;&gt; 1)] = L - R; &#125; &#125; &#125; if(!~t) for(int i = 0; i &lt; N; i++) x[i] = x[i] / N;&#125;const int N = 100 + 5;int dis[N][N];int n, m, t, x;struct Edge &#123; int u, v, c; double p[maxn]; void input() &#123; u = read&lt;int&gt;(), v = read&lt;int&gt;(), c = read&lt;int&gt;(); chkmin(dis[u][v], c); for(int i = 1; i &lt;= t; i++) p[i] = double(read&lt;int&gt;()) / 100000.0; &#125;&#125;E[N];Complex A[maxn], B[maxn];double S[N][maxn], f[N][maxn];void calc(int l, int r, int mid) &#123; static int base, len; for(int k = 0; k &lt; m; k++) &#123; int v = E[k].v; for(base = 1, len = 0; base &lt;= 2*r-l-mid+1; base &lt;&lt;= 1) ++ len; for(int i = 0; i &lt; base; i++) rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1) | ((i&amp;1) &lt;&lt; (len-1)); for(int i = 0; i &lt; base; i++) A[i] = B[i] = Complex(0, 0); for(int i = 0; i &lt; r-mid; i++) A[i] = Complex(f[v][r-i], 0); for(int i = 1; i &lt;= r-l; i++) B[i-1] = Complex(E[k].p[i], 0); DFT(A, base, 1); DFT(B, base, 1); for(int i = 0; i &lt; base; i++) A[i] = A[i] * B[i]; DFT(A, base, -1); for(int i = l; i &lt;= mid; i++) S[k][i] += A[r-i-1].real; &#125;&#125;void cdq_solve(int l, int r) &#123; if(l == r) &#123; for(int i = 0; i &lt; m; i++) chkmin(f[E[i].u][l], S[i][l] + E[i].c); return; &#125; int mid = (l + r) &gt;&gt; 1; cdq_solve(mid+1, r); calc(l, r, mid); cdq_solve(l, mid);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif memset(dis, oo, sizeof dis); n = read&lt;int&gt;(), m = read&lt;int&gt;(), t = read&lt;int&gt;(), x = read&lt;int&gt;(); for(int i = 1; i &lt;= n; i++) dis[i][i] = 0; for(int i = 0; i &lt; m; i++) E[i].input(); for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) chkmin(dis[i][j], dis[i][k] + dis[k][j]); for(int i = 1; i &lt;= n; i++) &#123; for(int T = 0; T &lt;= t; T++) f[i][T] = (i == n) ? 0 : oo; for(int T = t+1; T &lt;= 2*t; T++) f[i][T] = dis[i][n] + x; &#125; calc(1, t*2, t); cdq_solve(0, t); printf("%.10lf\n", f[1][0]); return 0;&#125;]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Probability</tag>
        <tag>Generating Function</tag>
      </tags>
  </entry>
</search>
