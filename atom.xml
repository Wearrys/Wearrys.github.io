<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wearry&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-17T01:50:55.954Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wearry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A brief proof of Birthday Paradox</title>
    <link href="http://yoursite.com/2020/birthday-paradox/"/>
    <id>http://yoursite.com/2020/birthday-paradox/</id>
    <published>2020-08-16T15:07:06.000Z</published>
    <updated>2020-08-17T01:50:55.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction"><em>Introduction</em></h1><h2 id="birthday-paradox"><em>Birthday Paradox</em></h2><blockquote><p>There are <span class="math inline">\(k\)</span> people whose birthdays are among set <span class="math inline">\(B\)</span> with size <span class="math inline">\(n\)</span>, the probability that there are <strong>at least</strong> a pair of people have the same birthday is greater than <span class="math inline">\(\frac{1}{2}\)</span> when <span class="math inline">\(k \ge 1.2 \sqrt{n} + 1\)</span></p></blockquote><a id="more"></a><h1 id="proof"><em>Proof</em></h1><p>Suppose each person's birthday is <strong>independent uniform</strong> in <span class="math inline">\(B\)</span>, then the probability that don't exist such a pair is:</p><p><span class="math display">\[P = \prod_{i=0}^{k-1} \left(1 - \frac{i}{n}\right)\]</span></p><p>to prove <span class="math inline">\(P \le \frac{1}{2}\)</span>, we use the result in analysis that:</p><blockquote><p><span class="math inline">\(\forall x \in \mathbb{R}, 1 + x \le \mathrm{e}^x\)</span> <img src="/img/exp.png"></p></blockquote><p>then:</p><p><span class="math display">\[\begin{aligned}P &amp;\le \exp \left(\sum_{i=0}^{k-1} -\cfrac{i}{n}\right) \\&amp;\le \exp \left(-\frac{(k-1)^2}{2n}\right) \\&amp;\le \exp \left(-\frac{(1.2 \sqrt{n})^2}{2n}\right) \\&amp;= \exp(-0.72) &lt; \frac{1}{2} \\\end{aligned}\]</span></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;introduction&quot;&gt;&lt;em&gt;Introduction&lt;/em&gt;&lt;/h1&gt;
&lt;h2 id=&quot;birthday-paradox&quot;&gt;&lt;em&gt;Birthday Paradox&lt;/em&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;There are &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; people whose birthdays are among set &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; with size &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;, the probability that there are &lt;strong&gt;at least&lt;/strong&gt; a pair of people have the same birthday is greater than &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\)&lt;/span&gt; when &lt;span class=&quot;math inline&quot;&gt;\(k \ge 1.2 \sqrt{n} + 1\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Probability" scheme="http://yoursite.com/tags/Probability/"/>
    
      <category term="Real Analysis" scheme="http://yoursite.com/tags/Real-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Cryptography Notes</title>
    <link href="http://yoursite.com/2020/cryptography/"/>
    <id>http://yoursite.com/2020/cryptography/</id>
    <published>2020-07-07T13:37:14.000Z</published>
    <updated>2020-08-26T18:32:29.702Z</updated>
    
    <content type="html"><![CDATA[<p>Some notes of 🔒 cryptography lessons</p><p><strong>TODO</strong>:</p><ul class="task-list"><li><input type="checkbox" disabled checked>Reconstruct the architecture of this post</li><li><input type="checkbox" disabled>Complete other contents</li></ul><a id="more"></a><h1 id="preliminary-fundamental-discrete-probability"><em>Preliminary: Fundamental Discrete Probability</em></h1><p>Suppose <span class="math inline">\(U\)</span> is a finite set.</p><h2 id="probability-distribution"><em>Probability Distribution</em></h2><blockquote><p>a <code>probability distribution</code> <span class="math inline">\(P\)</span> over <span class="math inline">\(U\)</span> is a function <span class="math display">\[P: U \rightarrow [0,1]\]</span> s.t. <span class="math display">\[\sum_{x \in U} P(x) = 1\]</span></p></blockquote><p>Some examples:</p><ul><li>Uniform distribution: <span class="math inline">\(\forall x \in U, P(x) = \dfrac{1}{|U|}\)</span></li><li>Pointed distribution: <span class="math inline">\(\exists x \in U, P(x) = 1\)</span></li></ul><h2 id="event"><em>Event</em></h2><blockquote><p>an <code>event</code> is a subset <span class="math inline">\(E\)</span> of <span class="math inline">\(U\)</span>, define the probability of <span class="math inline">\(E\)</span> under <code>probability distribution</code> <span class="math inline">\(P\)</span> as below: <span class="math display">\[Pr[E] = \sum_{x \in E} P(x)\]</span></p></blockquote><h3 id="the-union-bound"><em>The Union Bound</em></h3><p>By definition, we can obviously get:</p><p><span class="math display">\[Pr[A_1 \cap A_2] + Pr[A_1 \cup A_2] = Pr[A_1] + Pr[A_2]\]</span></p><p>Which also implies that:</p><p><span class="math display">\[Pr[A_1 \cup A_2] \le Pr[A_1] + Pr[A_2]\]</span></p><h2 id="random-variable"><em>Random Variable</em></h2><blockquote><p>a <code>random variable</code> <span class="math inline">\(X\)</span> is a function <span class="math display">\[X:U \rightarrow V\]</span> where <span class="math inline">\(V\)</span> is <strong>range</strong> of <span class="math inline">\(X\)</span></p></blockquote><p>Example <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p><p><span class="math display">\[\begin{aligned}X:\{0, 1\}^n \rightarrow \{0, 1\} \\X(b) = LSB(b) \in \{0, 1\}\end{aligned}\]</span></p><p>As you can see, <code>random variable</code> <span class="math inline">\(X\)</span> can also induce <code>probability distribution</code> from <span class="math inline">\(U\)</span> to <span class="math inline">\(V\)</span> (Suppose <span class="math inline">\(P\)</span> is a distribution on <span class="math inline">\(U\)</span>):</p><p><span class="math display">\[\forall v \in V, Q(v) = Pr[X = v] = Pr[X^{-1}(v)]\]</span></p><h3 id="uniform-random-variable"><em>Uniform Random Variable</em></h3><p>Specially, when <span class="math inline">\(P\)</span> is uniform distribution and <span class="math inline">\(X(r) = r\)</span> for all <span class="math inline">\(r \in U\)</span>, then:</p><p><span class="math display">\[\forall r \in U, Pr[X = r] = \frac{1}{|U|}\]</span></p><p>this is called <code>uniform random variable</code>, denoted by <span class="math inline">\(X \xleftarrow{R} U\)</span></p><h2 id="independence"><em>Independence</em></h2><ul><li>Two <code>events</code> <span class="math inline">\(A, B\)</span> are independent <strong>iff</strong>: <span class="math inline">\(Pr[A \cap B] = Pr[A] \times Pr[B]\)</span></li><li>Two <code>random variables</code> <span class="math inline">\(A, B\)</span> are independent <strong>iff</strong> <span class="math inline">\(\forall a \in V_A, b \in V_B\)</span>:</li></ul><p><span class="math display">\[Pr[A = a \,\,\mathrm{and}\,\, B = b] = Pr[A = a] \times Pr[B = b]\]</span></p><blockquote><p>For better understanding of independence, consider the example below: Suppose a dice numbered by <span class="math inline">\(D = \{1, 2, \dots, 6\}\)</span> and 2 <code>random variables</code> <span class="math inline">\(A, B\)</span>: <span class="math display">\[ \begin{aligned}&amp;A:D \rightarrow \{0, 1\} &amp;A(x) = [x \equiv 0 \pmod 2] \\&amp;B:D \rightarrow \{0, 1\} &amp;B(x) = [x \equiv 0 \pmod 3] \end{aligned} \]</span> For uniform distribution of <span class="math inline">\(D\)</span>, <span class="math inline">\(A, B\)</span> are obviously independent. Think about conditions below:</p><ol type="1"><li><span class="math inline">\(B(x) = [x \equiv 0 \pmod 4]\)</span></li><li><span class="math inline">\(D = \{1, 2, \dots, 5\}\)</span></li></ol></blockquote><h2 id="more-about-probability"><em>More about Probability</em></h2><p><a href="https://crypto.stanford.edu/~blynn/pr/" target="_blank" rel="noopener">See also</a></p><h1 id="i-pseudorandomness"><em>I: Pseudorandomness</em></h1><p><code>Pseudorandomness</code> measures the extent to which a sequence of numbers, though produced by a completely deterministic and repeatable process, appear to be patternless.</p><h2 id="pseudo-random-generator"><em>Pseudo-random Generator</em></h2><p>A <code>Pseudo-random Generator</code>, or <code>PRG</code> for short, is an efficient, deterministic algorithm <span class="math inline">\(G\)</span> that given as input a <code>seed</code> <span class="math inline">\(s\)</span>, computes an output <span class="math inline">\(r\)</span>. Both <span class="math inline">\(s\)</span> and <span class="math inline">\(r\)</span> come from a finite space, called <span class="math inline">\(\mathcal{S}\)</span> and <span class="math inline">\(\mathcal{R}\)</span> respectively.</p><p>Typically <span class="math inline">\(\mathcal{S}\)</span> and <span class="math inline">\(\mathcal{R}\)</span> are sets of bit strings of some prescribed length. We can also regard <span class="math inline">\(G\)</span> as an abstract function defined over <span class="math inline">\(\mathcal{(S, R)}\)</span>:</p><p><span class="math display">\[G: \mathcal{S} = \{0, 1\}^l \rightarrow \mathcal{R} = \{0, 1\}^L\]</span></p><h3 id="security"><em>Security</em></h3><p>We say a PRG <span class="math inline">\(G\)</span> is secure if <span class="math inline">\(G(s)\)</span> and <span class="math inline">\(r\)</span> are <strong>computational indistinguishable</strong>, among which <span class="math inline">\(s\)</span> is chosen uniform randomly from <span class="math inline">\(\mathcal{S}\)</span> and <span class="math inline">\(r\)</span> is chosen at random from <span class="math inline">\(\mathcal{R}\)</span>.</p><p>To illustrate <strong>computational indistinguishability</strong>, the definition is formulated as an attack game:</p><blockquote><h4 id="attack-game-prg-and-advantage"><em>Attack Game (PRG) and Advantage</em></h4><p>For a given PRG <span class="math inline">\(G\)</span> defined over <span class="math inline">\(\mathcal{(S, R)}\)</span>, and for a given adversary <span class="math inline">\(\mathcal{A}\)</span>, we define two experiments, Experiment <span class="math inline">\(0\)</span> and Experiment <span class="math inline">\(1\)</span>:</p><p><strong>Experiment</strong> <span class="math inline">\(b\)</span>:</p><ul><li><p>The Challenger computes <span class="math inline">\(r \in \mathcal{R}\)</span> as follows: <img src="/img/PRG-ADV.png" alt="PRG-ADV"></p><ul><li>if <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(s \xleftarrow{R} \mathcal{S}, r \leftarrow G(s)\)</span></li><li>if <span class="math inline">\(b = 1\)</span>, <span class="math inline">\(r \xleftarrow{R} \mathcal{R}\)</span></li></ul></li><li><p>Given <span class="math inline">\(r\)</span>, the adversary computes and outputs a bit <span class="math inline">\(\hat{b} \in \{0, 1\}\)</span></p></li></ul><p>For <span class="math inline">\(b \in \{0, 1\}\)</span>, let <span class="math inline">\(W_b\)</span> be the event that <span class="math inline">\(\mathcal{A}\)</span> outputs <span class="math inline">\(\hat{b} = 1\)</span> in Experiment <span class="math inline">\(b\)</span>. We define <span class="math inline">\(\mathcal{A}\)</span>'s <code>advantage</code> with respect to <span class="math inline">\(G\)</span> as</p><p><span class="math display">\[PRG_{adv} [\mathcal{A}, G] = \left|Pr[W_0] - Pr[W_1]\right|\]</span></p></blockquote><p>Now we can define a PRG <span class="math inline">\(G\)</span> is <strong>secure</strong> if the value <span class="math inline">\(PRG_{adv} [\mathcal{A}, G]\)</span> is negligible <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> for all efficient adversaries <span class="math inline">\(\mathcal{A}\)</span>.</p><h2 id="pseudo-random-function"><em>Pseudo-random Function</em></h2><p>A <code>Pseudo-random Function(PRF)</code> <span class="math inline">\(F\)</span> is a deterministic algorithm that has two inputs: a <code>key</code> <span class="math inline">\(k\)</span> and an <code>input data block</code> <span class="math inline">\(x\)</span>; its output <span class="math inline">\(y := F(k, x)\)</span> is called an <code>output data block</code>. We denote the finite space of <span class="math inline">\(k, x, y\)</span> with <span class="math inline">\(\mathcal{(K, X, Y)}\)</span>, over which is <span class="math inline">\(F\)</span> defined.</p><p>Intuitively, our notion of security says that for a randomly chosen key <span class="math inline">\(k\)</span>, <span class="math inline">\(F(k, \cdot )\)</span> is indistinguishable from a random function from <span class="math inline">\(\mathcal{X}\)</span> to <span class="math inline">\(\mathcal{Y}\)</span></p><blockquote><h3 id="notation"><strong>Notation</strong></h3><p><span class="math display">\[Funs[\mathcal{X, Y}] = \{f: \mathcal{X} \rightarrow \mathcal{Y}\}\]</span> clearly we know that <span class="math display">\[|Funs[\mathcal{X, Y}]| = |\mathcal{Y}|^{|\mathcal{X}|}\]</span></p></blockquote><h3 id="attack-game-prf">Attack Game (PRF)</h3><p>Similarly we can define two experiments, Experiment <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, for a PRF <span class="math inline">\(F\)</span> defined over <span class="math inline">\(\mathcal{(K, X, Y)}\)</span>:</p><p><strong>Experiment</strong> <span class="math inline">\(b\)</span>:</p><ul><li>The challenger selects <span class="math inline">\(f\)</span> as follows:<ul><li>if <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(k \xleftarrow{R} \mathcal{K}, f \leftarrow F(k, \cdot)\)</span></li><li>if <span class="math inline">\(b = 1\)</span>, <span class="math inline">\(f \xleftarrow{R} Funs[\mathcal{X, Y}]\)</span></li></ul></li><li>The adversary <span class="math inline">\(\mathcal{A}\)</span> submits a sequence of queries <span class="math inline">\(x_1, \dots, x_q\)</span>, and receives <span class="math inline">\(y_i = f(x_i)\)</span> for each <span class="math inline">\(i\)</span> from the challenger</li><li>The adversary computes <span class="math inline">\(\hat{b} \in {0, 1}\)</span></li></ul><p>Let <span class="math inline">\(W_b\)</span> be the event <span class="math inline">\(\mathcal{A}\)</span> outputs <span class="math inline">\(1\)</span> in Experiment <span class="math inline">\(b\)</span>, the <code>advantage</code> is also defined by:</p><p><span class="math display">\[PRF_{adv} [\mathcal{A}, F] = |Pr[W_0] - Pr[W_1]|\]</span></p><p>We say a PRF <span class="math inline">\(F\)</span> is <strong>secure</strong> if all efficient adversary <span class="math inline">\(A\)</span> have a negligible advantage.</p><h2 id="pseudo-random-permutation"><em>Pseudo-random Permutation</em></h2><p>Also called <a href="#bc">Block Cipher</a>, is a special PRF which is also invertible.</p><h1 id="ii-cipher"><em>II: Cipher</em></h1><p>Throughout history, there were many ways of encryption, however, some of them have been proved unsafe. The question now is whether a particular <code>cipher</code> is <strong>secure</strong> and how to construct a <strong>secure</strong> one.</p><h2 id="stream-cipher"><em>Stream Cipher</em></h2><blockquote><p>A <code>cipher</code> defined over a triple <span class="math inline">\((\mathcal{K, M, C})\)</span> is a pair of <strong>efficient</strong><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> algos <span class="math inline">\((E, D)\)</span> where:</p><p><span class="math display">\[\begin{aligned}E: \mathcal{K \times M} \rightarrow \mathcal{C} \\D: \mathcal{K \times C} \rightarrow \mathcal{M}\end{aligned}\]</span> s.t. <span class="math inline">\(\forall m \in \mathcal{M}, k \in \mathcal{K}\)</span> <span class="math display">\[m = D(k, E(k, m))\]</span> and <span class="math inline">\(\mathcal{K, M, C}\)</span> denote the space of keys, messages and cipher texts.</p></blockquote><h3 id="otp"><em>One Time Pad</em></h3><p>An example cipher over <span class="math inline">\(\mathcal{K, M, C} = \{0, 1\}^n\)</span> and:</p><p><span class="math display">\[\begin{aligned}E(k, m) = k \oplus m \\D(k, m) = k \oplus m \\\end{aligned}\]</span></p><h2 id="perfect-secrecy"><em>Perfect Secrecy</em></h2><p>The basic idea behind perfect secrecy is: cipher text should reveal no "info" about plain text.</p><blockquote><p>A <code>cipher</code> <span class="math inline">\((E, D)\)</span> over <span class="math inline">\(\{\mathcal{K, M, C}\}\)</span> has <code>perfect secrecy</code> <strong>iff</strong>:</p><p><span class="math inline">\(\forall m_0, m_1 \in \mathcal{M} \,\,\mathrm{that}\,\, |m_0| = |m_1|, c \in \mathcal{C}\)</span>: <span class="math display">\[Pr[E(k, m_0) = c] = Pr[E(k, m_1) = c]\]</span> where <span class="math inline">\(k \xleftarrow{R} \mathcal{K}\)</span></p></blockquote><p>It's not hard to see that when attacker gets a cipher text, he will have no idea what the plain text is. By definition, we can also prove <a href="#otp">One Time Pad</a> has <code>perfect secrecy</code>.</p><p>However, <code>perfect secrecy</code> is too hard to satisfy because we have theorem below:</p><blockquote><p>If a <code>cipher</code> has <code>perfect secrecy</code>, then: <span class="math display">\[|\mathcal{K}| \ge |\mathcal{M}|\]</span> which means the length of keys mustn't less than length of messages.</p></blockquote><p>That somehow makes no sense for if we have some way sending and receiving such long keys secretly, then it's absolutely unnecessary to use <code>cipher</code>.</p><h2 id="bc"><em>Block Cipher</em></h2><h1 id="iii-mac"><em>III: MAC</em></h1><h1 id="iv-attack-security"><em>IV: Attack &amp; Security</em></h1><section class="footnotes" role="doc-endnotes"><hr><ol><li id="fn1" role="doc-endnote"><p>LSB is a function which gets the last significant bit of a bit-string.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Negligible means small enough so that cannot be detected even by enormous samples.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>Theoretically, efficient means runs in polynomial time; Practically it means runs within a certain time period.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Some notes of 🔒 cryptography lessons&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt;:&lt;/p&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; disabled checked&gt;
Reconstruct the architecture of this post&lt;/li&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; disabled&gt;
Complete other contents&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Probability" scheme="http://yoursite.com/tags/Probability/"/>
    
      <category term="Number Theory" scheme="http://yoursite.com/tags/Number-Theory/"/>
    
      <category term="Induction" scheme="http://yoursite.com/tags/Induction/"/>
    
  </entry>
  
  <entry>
    <title>若干趣题</title>
    <link href="http://yoursite.com/2020/exercise-of-thoughts/"/>
    <id>http://yoursite.com/2020/exercise-of-thoughts/</id>
    <published>2020-02-10T14:04:22.000Z</published>
    <updated>2020-06-22T09:24:00.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>宅家没事的时候找的乐子，不定期更新，大概。</p><a id="more"></a><h2 id="section">1</h2><h3 id="description">Description</h3><p>有 <span class="math inline">\(n\)</span> 个人，其中有好有坏，每个人都知道其他任何人是好是坏，现在可以进行若干次询问，每次询问形如 <span class="math inline">\((i, j)\)</span>，表示问第 <span class="math inline">\(i\)</span> 个人第 <span class="math inline">\(j\)</span> 个人是否是好人 <span class="math inline">\((i \neq j)\)</span>，同时好人一定说真话，坏人可能说假话，问：</p><ol type="1"><li>如果有多于一半的人是好的，是否存在策略能够在不超过 <span class="math inline">\(n\)</span> 次询问下确定一个好人。</li><li>如果有恰好一半的人是坏人，是否存在上述策略。</li></ol><h3 id="solution">Solution</h3><h4 id="section-1">1</h4><p>考虑维护一个序列，初始时加入编号为 <span class="math inline">\(1\)</span> 的人，接下来依次将其他人加入，每次加入的时候询问序列末尾的人这个人是好人还是坏人，如果答案是坏人则删除末尾，否则将这个新加入的作为末尾，正确性不难验证：</p><ol type="1"><li>每次删除的至少有一个坏人，因此最后序列剩下的人中至少有一个好人。</li><li>如果序列中至少有一个好人，则序列的末尾一定也是好人。</li></ol><h4 id="section-2">2</h4><p>不能，如果所有坏人都永远说谎，则他们与好人没有区别。</p><h2 id="section-3">2</h2><h3 id="巴塞尔公式">巴塞尔公式</h3><p><span class="math display">\[    \sum_{n=1}^{\infty} \frac{1}{n^2} = \frac{\pi^2}{6}\]</span></p><h3 id="证明">证明</h3><p>首先注意到：</p><p><span class="math display">\[\begin{aligned}    I=&amp;\int_0^1 \mathrm{d} x \int_0^1 \frac{1}{1-xy} \mathrm{d} y \\    =&amp;\iint_D \sum_{i=0}^{\infty} (xy)^i \mathrm{d}x\mathrm{d}y \\    =&amp;\sum_{i=0}^{\infty} \iint_D (xy)^i \mathrm{d}x\mathrm{d}y \\    =&amp;\sum_{i=0}^{\infty} \left(\int_0^1 x^i \mathrm{d} x\right)^2 \\    =&amp;\sum_{i=1}^{\infty} \frac{1}{i^2}\end{aligned}\]</span></p><p>故只需证明 <span class="math inline">\(I = \dfrac{\pi^2}{6}\)</span> 即可，考虑变量替换：</p><p><span class="math display">\[\begin{cases}    x = u + v \\    y = u - v\end{cases},\frac{\partial(x, y)}{\partial(u, v)} = \left|\begin{matrix} 1 &amp; 1 \\ 1 &amp; -1 \end{matrix} \right| = -2\]</span></p><p>则：</p><p><span class="math display">\[\begin{aligned}I &amp;= 2 \iint_{D_{uv}} \frac{1}{1 - u^2 + v^2} \mathrm{d} u \mathrm{d} v \\&amp;= 4 \left(\int_0^{\frac{1}{2}} \mathrm{d} u \int_0^{u} \frac{1}{1-u^2+v^2} \mathrm{d} v + \int_{\frac{1}{2}}^{1} \mathrm{d}u \int_0^{1-u} \frac{1}{1-u^2+v^2} \mathrm{d} v\right) \\&amp;= 4 \left(\int_0^{\frac{1}{2}} \frac{1}{\sqrt{1-u^2}} \arctan \frac{u}{\sqrt{1-u^2}} \mathrm{d} u + \int_{\frac{1}{2}}^{1} \frac{1}{\sqrt{1-u^2}} \arctan \frac{1-u}{\sqrt{1-u^2}} \mathrm{d} u\right) \\&amp;= 4 \left(\int_0^{\frac{1}{2}} \arctan \frac{u}{\sqrt{1-u^2}} \mathrm{d} \arctan \frac{u}{\sqrt{1-u^2}}   -2       \int_{\frac{1}{2}}^1 \arctan \frac{1-u}{\sqrt{1-u^2}} \mathrm{d} \arctan \frac{1-u}{\sqrt{1-u^2}} \right) \\&amp;= 4 \times \frac{1}{2} \times \left(\frac{\pi}{6}\right)^2 + 4 \times \left(\frac{\pi}{6}\right)^2 = \frac{\pi^2}{6} \\&amp;&amp; \square\end{aligned}\]</span></p><h3 id="应用">应用</h3><blockquote><p>任取两个正整数，求它们互质的概率</p></blockquote><p>考虑任意质因子 <span class="math inline">\(p\)</span>，如果两个数同时是 <span class="math inline">\(p\)</span> 的倍数，则不会互质，这个概率显然为 <span class="math inline">\(\dfrac{1}{p^2}\)</span>，因此互质的概率可以写成如下形式：</p><p><span class="math display">\[\begin{aligned}P &amp;= \prod_{p\, \mathrm{is\ prime}} \left(1 - \frac{1}{p^2}\right) \\&amp;= \prod_{p\, \mathrm{is\ prime}} \cfrac{1}{\sum_{i=0}^{\infty} \left(\cfrac{1}{p^2}\right)^i} \\&amp;= \frac{1}{\sum_{i=1}^{\infty} \frac{1}{i^2}} \\&amp;= \frac{6}{\pi^2}\end{aligned}\]</span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;宅家没事的时候找的乐子，不定期更新，大概。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Combinatorial" scheme="http://yoursite.com/tags/Combinatorial/"/>
    
      <category term="Induction" scheme="http://yoursite.com/tags/Induction/"/>
    
  </entry>
  
  <entry>
    <title>互测题总结</title>
    <link href="http://yoursite.com/2018/problem-select/"/>
    <id>http://yoursite.com/2018/problem-select/</id>
    <published>2018-10-02T02:58:09.000Z</published>
    <updated>2020-07-14T12:02:42.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="string">String</h3><h4 id="description">Description</h4><blockquote><p>称一个仅由<code>a</code>, <code>b</code>, <code>c</code>组成的字符串 <span class="math inline">\(S\)</span> 是平衡的当且仅当对于 <span class="math inline">\(S\)</span> 的任意一个连续子串 <span class="math inline">\(T\)</span>, 任意两种字符的出现次数之差都小于等于 <span class="math inline">\(k\)</span>, 求长度为 <span class="math inline">\(n\)</span> 的平衡串的数量.</p></blockquote><p><span class="math inline">\(n \le 10^9, K \le 8\)</span></p><a id="more"></a><h4 id="solution">Solution</h4><p>定义 <span class="math inline">\(f_{a, b}(i)\)</span> 表示在前 <span class="math inline">\(i\)</span> 个字符中 <code>a</code> 和 <code>b</code> 出现次数之差, 在只考虑 <code>a</code>, <code>b</code> 两种字符的条件等价于:</p><p><span class="math display">\[\max_{i=1}^{n} f_{a, b}(i) - \min_{i=1}^{n} f_{a, b}(i) \le k\]</span></p><p>注意到如果 <span class="math inline">\(f_{a, b}\)</span> 的值域区间长度为 <span class="math inline">\(len\)</span>, 则被所有长度为 <span class="math inline">\(k\)</span> 的值域区间计算的次数是 <span class="math inline">\(k - len + 1\)</span>. 记 <span class="math inline">\(g(x, y, z)\)</span> 表示三种 <span class="math inline">\(f\)</span> 的值域区间长度限制分别为 <span class="math inline">\(x, y, z\)</span> 时的方案数, 那么可以容斥计算答案:</p><p><span class="math display">\[ans = g(k, k, k) - 3 g(k, k, k-1) + 3 g(k, k-1, k-1) - g(k-1, k-1, k-1)\]</span></p><p>考虑如何计算 <span class="math inline">\(g(x, y, z)\)</span>, 以 <span class="math inline">\(x\)</span> 为例, 每一个合法的区间一定可以表示成 <span class="math inline">\(s_x + l_x \mid l_x \in [0, x]\)</span> 的形式.</p><p>因为初始状态的 <span class="math inline">\(l\)</span> 确定了 <span class="math inline">\(s\)</span> , 接下来的转移只需要保证 <span class="math inline">\(l\)</span> 的范围即可, 由于:</p><p><span class="math display">\[f_{a, b}(i) - f_{a, c}(i) = f_{c, b}(i)\]</span></p><p>考虑对于 <span class="math inline">\(z\)</span> 的限制, 有:</p><p><span class="math display">\[s_z + s_y - s_x \le l_x - l_y \le s_z + s_y - s_x + l_z\]</span></p><p>每次转移之前枚举一下 <span class="math inline">\(s_z + s_y - s_x\)</span> 即可, 这样状态只需要考虑 <span class="math inline">\(l_x, l_y\)</span> 即可, 并且初始状态唯一确定 <span class="math inline">\(s_x, s_y, s_z\)</span>.</p><h3 id="sequence">Sequence</h3><h4 id="description-1">Description</h4><blockquote><p>对长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a_i\}\)</span>, 定义 <span class="math inline">\(sum(l, r)\)</span> 为第 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 项的元素之和, <span class="math inline">\(inc(l, r)\)</span> 为第 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 项的非空上升子序列的最大权值和, 求 <span class="math inline">\(\max_{1 \le l,\, r \le n} sum(l, r) - inc(l, r)\)</span>, 以及同时满足区间长度最小的 <span class="math inline">\((l, r)\)</span> 的数量.</p></blockquote><p><span class="math inline">\(n \le 2 \times 10^5, |a_i| \le 40\)</span></p><h4 id="solution-1">Solution</h4><p>由于权值的范围比较小, <span class="math inline">\(inc\)</span> 的范围也不大, 同时一定存在方案使得 <span class="math inline">\(inc\)</span> 中只包含正数.</p><p>考虑从左到右枚举右端点, 由于最小化区间长度的需要, 记录 <span class="math inline">\(dp(i, j)\)</span> 表示右边界不超过当前枚举的位置, 最长上升子序列的权值和为 <span class="math inline">\(i\)</span> 且最后一位的权值为 <span class="math inline">\(j\)</span> 时最靠右的左端点的位置. 转移可以做到 <span class="math inline">\(O(n |a_i|^3)\)</span></p><p>接下来考虑计算答案, 从大到小枚举 <span class="math inline">\(inc\)</span> 可能的值, 并求其最靠右的左端点如果左端点是单调增的则说明选择中间这部分的左端点 <span class="math inline">\(inc\)</span> 会发生变化, 找一个能最优化 <span class="math inline">\(sum\)</span> 的同时区间长度最小的左端点即可.</p><h3 id="game">Game</h3><h4 id="description-2">Description</h4><blockquote><p><span class="math inline">\(n\)</span> 个人在一起玩游戏每个人初始有一张牌, 牌上的数字构成一个 <span class="math inline">\(1-n\)</span> 的排列, 所有人从左到右进行决策: 翻开自己的牌并留在原地, 或者选一个之前的人与其交换手中的牌并离开游戏, 之前的人将他的牌翻开. 每个人都会采取最佳策略, 并希望自己手中的牌上的数字尽可能大. 定义 <span class="math inline">\(E(n)\)</span> 为 <span class="math inline">\(n\)</span> 个人进行游戏最后留在原地的人的数量的期望.</p></blockquote><p><span class="math display">\[\begin{aligned}S_k(n) = \begin{cases}    E(n)  &amp; \text{k = 0} \\    \sum_{i=1}^{n} S_{k-1}(i) &amp; \text{otherwise} \\\end{cases}\end{aligned}\]</span></p><p>求 <span class="math inline">\(S_k(n)\)</span>, 保留 <span class="math inline">\(10\)</span> 位有效数字.</p><p><span class="math inline">\(k \le 50, n \le 10^{15}\)</span></p><h4 id="solution-2">Solution</h4><p>首先需要分析每个人的策略, 已知的信息有两部分, 留在原地的人手中的数字集合<span class="math inline">\(P\)</span>, 没有进行决策的人手中的数字集合<span class="math inline">\(R\)</span>. 考虑证明最优策略下发生交换当且仅当 <span class="math inline">\(\min\{R\} &lt; \max\{P\}\)</span>.</p><p>不妨使用数学归纳法证明, 对于最后一个做决策的人, 决策正确性显然, 考虑剩下的人:</p><ul><li><p>当 <span class="math inline">\(\min\{R\} &gt; \max\{P\}\)</span> 时, 显然翻开手中的牌无论如何都不会再劣于 <span class="math inline">\(\max\{P\}\)</span>.</p></li><li><p>当 <span class="math inline">\(\min\{R\} &lt; \max\{P\}\)</span> 时, 考虑反证翻开当前的牌不会比 <span class="math inline">\(\max\{P\}\)</span> 更优:</p><ul><li>如果翻开的牌优于 <span class="math inline">\(\max\{P\}\)</span>, 由于在这之前有 <span class="math inline">\(\min\{R\} &lt; \max\{P\}\)</span>, 在最小值被翻出之前接下来的人都会选择与最大的位置交换, 如果最大值所在的位置没有发生变化这个位置最后会变成 <span class="math inline">\(\min\{R\}\)</span> 且不会有人再和他交换手中的牌, 否则这个位置需要先变得小于原本的 <span class="math inline">\(\max\{P\}\)</span>.</li><li>如果翻开的牌劣于 <span class="math inline">\(\max\{P\}\)</span> 则类似上述情况中先变得小于原本 <span class="math inline">\(\max\{P\}\)</span> 的情况, 每一个完整过程中要么 <span class="math inline">\(\max\{P\}\)</span> 变成 <span class="math inline">\(\min\{R\}\)</span>, 要么 <span class="math inline">\(\max\{P\}\)</span> 的位置发生变化, 最终一定都会劣于最初的 <span class="math inline">\(\max\{P\}\)</span>.</li></ul></li></ul><p>接下来考虑 <span class="math inline">\(E(n)\)</span>, 第 <span class="math inline">\(i\)</span> 个人选择留在原地当且仅当第 <span class="math inline">\(i-1\)</span> 个人手中的牌恰好是后缀最小值, 于是:</p><p><span class="math display">\[E(n) = \sum_{i=1}^{n} \frac{1}{i}\]</span></p><p>考虑生成函数:</p><p><span class="math display">\[\begin{aligned}F(x) &amp;= \sum_{i=1}^{\infty} \frac{1}{i} x^i \\     &amp;= \int \frac{1}{1 - x} \\     &amp;= -\ln(1 - x) \\\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}E(x) &amp;= \frac{F(x)}{1 - x} \\     &amp;= \frac{-\ln(1 - x)}{1 - x}\end{aligned}\]</span></p><p>接下来计算 <span class="math inline">\(S_k(n)\)</span>:</p><p><span class="math display">\[ \begin{aligned}S_k(x) &amp;= \frac{S_{k-1}(x)}{1 - x} \\       &amp;= \frac{-\ln(1 - x)}{(1 - x)^{k + 1}} \\S_k&#39;(x) &amp;= \frac{(-\ln(1-x))&#39;}{(1-x)^{k + 1}} - \ln(1 - x) \left( \frac{1}{(1 - x)^{k+1}} \right)&#39; \\        &amp;= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \left( -\frac{1}{(1 - x)^{2k + 2}} ((1-x)^{k+1})&#39; \right) \\        &amp;= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \frac{(k + 1) (1 - x)^k}{(1 - x)^{2k+2}} \\        &amp;= \frac{1}{(1 - x)^{k + 2}} + (k + 1) S_{k+1}(x)\end{aligned}\]</span></p><p>考虑 <span class="math inline">\(x^n\)</span> 项的系数:</p><p><span class="math display">\[(n+1)S_k(n+1)x^n = {n + k + 2 \choose k + 1}x^n + (k + 1) S_{k + 1}(n) x^n\]</span></p><p><span class="math display">\[S_{k+1}(n) = \frac{(n+1)S_k(n+1) - {n + k + 2 \choose k + 1}}{k + 1}\]</span></p><p>对于 <span class="math inline">\(S_0(n)\)</span>, 使用调和级数的近似公式计算, 否则递归即可.</p><h3 id="power">Power</h3><h4 id="description-3">Description</h4><blockquote><p><span class="math inline">\(n\)</span> 个连续随机变量, 第 <span class="math inline">\(i\)</span> 个变量 <span class="math inline">\(x_i\)</span> 在 <span class="math inline">\([l_i, r_i]\)</span> 中均匀随机, 求 <span class="math inline">\(\max\{ (\sum{x_i})^m, a^m \}\)</span> 的期望值对 <span class="math inline">\(998244353\)</span> 取模的结果.</p></blockquote><p><span class="math inline">\(n \le 15, m \le 10^8, |a|, |l_i|, |r_i| \le 10^6\)</span></p><h4 id="solution-3">Solution</h4><p>连续概率实际上是合法的点集在 <span class="math inline">\(n\)</span> 维超立方体中的体积占比, 点集内部用积分计算期望即可. 对于 <span class="math inline">\([0, \infty)\)</span> 范围内的 <span class="math inline">\(n\)</span> 个连续随机变量 <span class="math inline">\(\{x_i\}\)</span>, 不难归纳得到满足 <span class="math inline">\(\sum x_i \le x\)</span> 的点构成的 <span class="math inline">\(n\)</span> 维超几何体在 <span class="math inline">\(n\)</span> 维空间中的体积是 <span class="math inline">\(\frac{x^n}{n!}\)</span>.</p><p>考虑 <span class="math inline">\(\sum{x_i}\)</span> 和 <span class="math inline">\(a\)</span> 的大小关系.</p><ul><li><span class="math inline">\(m\)</span> 为奇数时, 需要考虑两个区间, <span class="math inline">\([-\infty, a], [a, \infty]\)</span>.</li><li><span class="math inline">\(m\)</span> 为偶数时, 需要计算三个区间的答案, <span class="math inline">\([-\infty, -a], [-a, a], [a, \infty]\)</span>.</li></ul><p>那么要计算在每个区间内部的期望值, 考虑将每个 <span class="math inline">\(x_i\)</span> 表示为 <span class="math inline">\(l_i + y_i\)</span> 或 <span class="math inline">\(r_i + y_i\)</span>, <span class="math inline">\(2^n\)</span> 枚举所有不合法的变量集合进行容斥, 对于 <span class="math inline">\(\sum y_i \le K\)</span> 的限制可以转化成计算:</p><p><span class="math display">\[\int_{0}^{K} \frac{x^{n-1}}{(n-1)!} g(x) \mathrm{d}x\]</span></p><p><span class="math inline">\(g(x)\)</span> 表示当 <span class="math inline">\(\sum y_i = x\)</span> 时的答案, 同一个区间内的形式是相同的.</p><p>对于 <span class="math inline">\(\sum y_i \ge K\)</span> 的限制可以反过来将每个 <span class="math inline">\(x_i\)</span> 表示为 <span class="math inline">\(r_i - y_i\)</span> 或者 <span class="math inline">\(l_i - y_i\)</span>, 限制 <span class="math inline">\(-\sum y_i \ge K\)</span> 可以转化为 <span class="math inline">\(\sum y_i \le K\)</span> 的形式.</p><h3 id="bizi">Bizi</h3><h4 id="description-4">Description</h4><blockquote><p>给出两棵有根树, 大小分别是 <span class="math inline">\(n_1, n_2\)</span>, 可以进行三种操作: 1. 修改: 将一条边的边权从 <span class="math inline">\(x\)</span> 改为 <span class="math inline">\(y\)</span> , 代价为 <span class="math inline">\(|x - y| \times c1\)</span>. 2. 收缩: 选择一个点, 将它的所有子树连向他的父亲, 代价为这个点到父亲的边权 <span class="math inline">\(w \times c2\)</span>. 3. 生长: 选择任意一个点的一段连续的子树, 插入一个新点连向选择的点并成为这些子树的父亲, 代价为连向原来的点的边权 <span class="math inline">\(w \times c2\)</span>.</p></blockquote><blockquote><p>求出使得两颗树括号序列和边权相同需要的最小代价.</p></blockquote><p><span class="math inline">\(n1 \le 50,\, n2 \le 2000\)</span></p><h4 id="solution-4">Solution</h4><p>首先不难发现操作一和操作二互为逆操作, 所以可以只考虑操作二.</p><p>定义 <span class="math inline">\(dp(a, b, c, d)\)</span> 表示第一颗树中 <span class="math inline">\([a, b]\)</span> 表示的括号序列区间和第二棵树中 <span class="math inline">\([c, d]\)</span> 表示的括号序列区间变得相同需要的最小代价, 考虑左端点对应的括号在最终情况下的匹配情况进行转移:</p><p><span class="math display">\[dp(a, b, c, d) = \min \begin{cases} dp(a + 1, b, c, d) + w_{a} \times c2 \\dp(a, b, c + 1, d) + w_{c} \times c2 \\dp(a + 1, p_{a} - 1, b + 1, p_{b} - 1) + dp(p_{a} + 1, b, p_{c} + 1, d) + |w_{a} - w_{b}| \times c1\end{cases}\]</span></p><p><span class="math inline">\(p_x\)</span> 表示第 <span class="math inline">\(x\)</span> 个括号的匹配括号的位置, <span class="math inline">\(w_x\)</span> 表示第 <span class="math inline">\(x\)</span> 个括号和其父亲结点之间连边的边权.</p><p>看起来状态数是 <span class="math inline">\(O(n1^2n2^2)\)</span> 的, 实际上分析后发现有用的状态数只有 <span class="math inline">\(O(n1^2n2\log{n2})\)</span>: 因为考虑左端点进行转移和考虑右端点进行转移是等价的, 但是如果每次都选择第二棵树中子树大小较小的一侧进行转移, 关于第二棵树的状态数就是轻儿子的子树大小之和, 而这个值是不会超过 <span class="math inline">\(O(n2 \log{n2})\)</span> 的.</p><h3 id="circle">Circle</h3><h4 id="description-5">Description</h4><blockquote><p>平面上有 <span class="math inline">\(n\)</span> 个点, 求有多少个无序三元组 <span class="math inline">\((i, j, k)\)</span> 满足点 <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, <span class="math inline">\(k\)</span> 确定的圆经过坐标原点.</p></blockquote><p><span class="math inline">\(n \le 2000\)</span></p><h4 id="solution-5">Solution</h4><p>西姆松定理:</p><blockquote><p>三个点确定的圆上任选一点向这三个点构成的三角形三边所在直线分别作垂线, 垂足三点共线.</p></blockquote><p>证明可参考下图:</p><p><img src="/img/simson.png"></p><p>于是问题转化为求三点共线的数量.</p><h3 id="triangle">Triangle</h3><h4 id="description-6">Description</h4><blockquote><p>有一棵 <span class="math inline">\(n\)</span> 个点的树, 初始时树上没有石子, 可以进行若干次如下操作: 1. 如果点 <span class="math inline">\(u\)</span> 的所有子树 <span class="math inline">\(v\)</span> 上都恰好有 <span class="math inline">\(w_v\)</span> 颗石子, 则可以从手中拿出 <span class="math inline">\(w_u\)</span> 颗石子放在点 <span class="math inline">\(u\)</span> 上. 2. 将某个结点上的所有石子收回手中.</p><p>现在询问你对于每一个点 <span class="math inline">\(i\)</span>, 要使得 <span class="math inline">\(i\)</span> 上恰好放有 <span class="math inline">\(w_i\)</span> 颗石子, 初始时手中至少需要多少颗石子.</p></blockquote><p><span class="math inline">\(n \le 10^5, w_i \le 10^9\)</span></p><h4 id="solution-6">Solution</h4><p>首先可以发现操作的过程类似一个拓扑排序, 填上一个结点的石子之前先要将它的所有儿子都填上石子, 接着会立即收回儿子结点上的石子.</p><p>不妨反过来考虑, 定义一次操作为选择一个放有石子的点, 将它的儿子结点全部放上石子, 然后收回这个点的石子. 由于只需要考虑操作过程中石子数量的最大值, 可以发现反转顺序并不会影响答案.</p><p>用一个二元组 <span class="math inline">\((a, b)\)</span> 描述一次操作, <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> 分别表示在操作的过程中石子的总变化量和变化最大值, 注意到两个操作可以方便地合并:</p><p><span class="math display">\[(a, b) + (c, d) = (a + c, \max\{b, a + d\})\]</span></p><p>接下来考虑二元组 <span class="math inline">\(X = (a, b)\)</span> 和 <span class="math inline">\(Y = (c, d)\)</span> 之间的优先级, 不难得到以下优先级规则:</p><ol type="1"><li><span class="math inline">\(a \times c &lt; 0\)</span> 时, 总变化量小于 <span class="math inline">\(0\)</span> 的二元组优先级更高.</li><li><span class="math inline">\(a &lt; 0 ,\,\, c &lt; 0\)</span> 时, 变化最大值较小的二元组优先级更高.</li><li><span class="math inline">\(a &gt; 0 ,\,\, c &gt; 0\)</span> 时, 总变化量减去变化最大值较小的二元组优先级更高.</li></ol><p>以上规则也可利用交换法证明正确性. 又因为任意两个二元组合并得到的新二元组不会比原来的两个二元组都更优, 所以全局最优的二元组在可以选择的时候一定会马上选择, 于是得到一个贪心策略, 每次选择最优的二元组并将其和父亲当前对应的二元组进行合并, 可以发现这样能够得到整棵树的操作序列.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;string&quot;&gt;String&lt;/h3&gt;
&lt;h4 id=&quot;description&quot;&gt;Description&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;称一个仅由&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;组成的字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 是平衡的当且仅当对于 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的任意一个连续子串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;, 任意两种字符的出现次数之差都小于等于 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;, 求长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的平衡串的数量.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(n \le 10^9, K \le 8\)&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Combinatorial" scheme="http://yoursite.com/tags/Combinatorial/"/>
    
      <category term="Summary" scheme="http://yoursite.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>拓展埃氏筛法小结</title>
    <link href="http://yoursite.com/2018/ex-eratos-sieve/"/>
    <id>http://yoursite.com/2018/ex-eratos-sieve/</id>
    <published>2018-08-21T11:42:41.000Z</published>
    <updated>2018-11-29T19:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>学完洲阁筛之后忘得差不多了, 不过现在已经可以将洲阁筛扔进垃圾桶了...</p><a id="more"></a><h3 id="description">Description</h3><p>求:</p><p><span class="math display">\[h(n) = \sum_{i=1}^{n} f(i)\]</span></p><p>其中 <span class="math inline">\(f\)</span> 是定义在正整数集下的积性函数, 满足 <span class="math inline">\(f(p^c)\)</span> 能够快速计算.</p><h3 id="conversion">Conversion</h3><p>首先可以将所有要求的数按照是否只含大于 <span class="math inline">\(\sqrt{n}\)</span> 的质因子分为两类, 对于第一类数一定是一个质数, 而第二类数一定可以在某个较小的质因子处考虑到, 于是我们只关注不超过 <span class="math inline">\(\sqrt{n}\)</span> 的那些质因子.</p><p>定义 <span class="math inline">\(S_k(n, i)\)</span> 表示小于等于 <span class="math inline">\(n\)</span> 的数中与前 <span class="math inline">\(i\)</span> 个质数互质的所有数与<strong>所有质数</strong>的 <span class="math inline">\(k\)</span> 次方和, 容易得到转移:</p><p><span class="math display">\[S_k(n, i) = \begin{cases}S_k(n, i-1) &amp; n &lt; p_i^2 \\S_k(n, i-1) - p_i^k \times \left(S_k(\left \lfloor \frac{n}{p_i} \right \rfloor, i - 1) - S_k(p_{i-1}, i - 1)\right) &amp; \mathrm{otherwise} \end{cases}\]</span></p><p>在考虑完 <span class="math inline">\(\sqrt{n}\)</span> 以内的所有质因数后, <span class="math inline">\(S_k(n)\)</span> 中留下了所有质数的 <span class="math inline">\(k\)</span> 次方, 这样所有第一类数的函数值都可以快速计算.</p><p>类似地, 定义 <span class="math inline">\(G(n, i)\)</span> 表示小于等于 <span class="math inline">\(n\)</span> 的数中仅由第 <span class="math inline">\(i\)</span> 个以后的质数构成的数与<strong>所有质数</strong> <span class="math inline">\(x\)</span> 的 <span class="math inline">\(f(x)\)</span> 之和, 转移的方式类似:</p><p><span class="math display">\[G(n, i) = G(n, i+1) + \sum_{c=0}^{\substack{p_i^{c+1} \le n}} f(p_i^{c+1}) + f(p_i^c) \times \left(G(\left \lfloor \frac{n}{p_i^c} \right \rfloor, i+1) - G(p_i, i+1)\right)\]</span></p><p>复杂度约为 <span class="math inline">\(O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)\)</span></p><h3 id="code">Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SIV &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    uint val[M + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> prime[M + <span class="number">5</span>], pcnt;</span><br><span class="line">    uint s[M + <span class="number">5</span>], S[M + <span class="number">5</span>];</span><br><span class="line">    uint f[M + <span class="number">5</span>], F[M + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> uint <span class="title">gets</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= m ? s[x] : S[n / x]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> uint <span class="title">getf</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= m ? f[x] : F[n / x]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">my_sqrt</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1l</span>l * (r + <span class="number">1</span>) * (r + <span class="number">1</span>) &lt;= x) ++ r;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll _n)</span> </span>&#123;</span><br><span class="line">        m = my_sqrt(n = _n);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            val[i] = <span class="number">81</span> * i * i - <span class="number">27</span> * i + <span class="number">9</span>;</span><br><span class="line">            s[i] = i - <span class="number">1</span>;</span><br><span class="line">            S[i] = (n / i) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= m; ++p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[p] == s[p<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            prime[pcnt ++] = p;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">const</span> uint _s = s[p - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> ll q = <span class="number">1l</span>l * p * p, lim = min((ll) m, n / q), x = m / p, y = n / p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) S[i] -= S[i * p] - _s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= lim; ++i) S[i] -= s[y / i] - _s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= q; --i) s[i] -= s[i / p] - _s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            f[i] = s[i] * <span class="number">63</span>;</span><br><span class="line">            F[i] = S[i] * <span class="number">63</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e = pcnt; e &gt;= <span class="number">1</span>; --e) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = prime[e<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">const</span> ll q = <span class="number">1l</span>l * p * p, lim = min((ll) m, n / q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++i) &#123;</span><br><span class="line">                ll cur = n / i;</span><br><span class="line">                <span class="keyword">for</span>(ll t = p, c = <span class="number">1</span>; t * p &lt;= cur; t *= p, ++ c) &#123;</span><br><span class="line">                    F[i] += (getf(cur / t) - e * <span class="number">63</span>) * val[c] + val[c + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= q; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t = p, c = <span class="number">1</span>; t &lt;= cur / p; t *= p, ++ c) &#123;</span><br><span class="line">                    f[i] += (getf(cur / t) - e * <span class="number">63</span>) * val[c] + val[c + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学完洲阁筛之后忘得差不多了, 不过现在已经可以将洲阁筛扔进垃圾桶了...&lt;/p&gt;
    
    </summary>
    
    
      <category term="Number Theory" scheme="http://yoursite.com/tags/Number-Theory/"/>
    
  </entry>
  
  <entry>
    <title>记NOI2018</title>
    <link href="http://yoursite.com/2018/noi2018/"/>
    <id>http://yoursite.com/2018/noi2018/</id>
    <published>2018-07-30T00:38:56.000Z</published>
    <updated>2018-11-29T19:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了好久终于把博客修好了, 来填一些坑.</p><a id="more"></a><h3 id="day--1">Day -1</h3><p>上午在家无所事事, 收了下行李, 下午就到洋湖报到去了, 然后听说笔试时间调整到了上午, 感觉有点慌整个晚上都在背笔试.</p><h3 id="day-0">Day 0</h3><p>上午考笔试, 比预料中的简单很多, 没有什么快捷键之类的坑题也没有挂分, 试机就打了一个最简单的配置就跑了.</p><p>下午找了一间教室自习, 不知道干什么, 晚上懒得复习什么早早地睡了, 奇怪的是居然丝毫不紧张.</p><h3 id="day-1">Day 1</h3><p>第一试, 看了看题, 觉得题意都挺好理解的, 难度也基本按照题目顺序.</p><p>就直接开始写T1了, 写完 <span class="math inline">\(\log^2\)</span> 过了大样例直接丢到一边了, 然后看T2, 推了一个看起来有理有据的结论, 但不是很会算答案搞了很久大样例四个全错, 想了一下随便打了个特判过了其中两个, 又改了一下特判才在考试一半时间的时候过了大样例.</p><p>期间去上了一个厕所, 用掉20min...</p><p>看T3惊喜地发现68分特别傻逼, 飞快地码完过了大样例还有一个半小时, 正准备回去继续做T2最后20分的时候发现T1可能跑不过, 卡了很久的常, 期间竟然检查出好多致命的错误, 然后心里特别虚地不停检查, T2也没有继续想了.</p><p>好在最后并没有挂分.</p><h3 id="day-1.5">Day 1.5</h3><p>鸽了社会活动, 在自习室搞了一天颓.</p><p>直接打出了防沉迷警告...</p><h3 id="day-2">Day 2</h3><p>看完题目一直在想哪道题最简单, 然后T1补充了一个条件...</p><p>用了两个小时都没有从T1的倒数第二步推出最后一步, 想想当时可能真的受到了降智打击, 还自信地觉得T2比较可做, 码了很久发现是假算法, 感觉很慌滚去写T3暴力, 回来想先写T2的45分又不想放弃T1, 最后连T2的45分都没拿到...</p><p>感觉心态真的崩的厉害, 虽然最后查分发现意外的多了5分(大雾).</p><h3 id="总结">总结</h3><p>好像从去年NOIP以来, 身上一直有某种二试Debuff存在, 可能经常性的因为第一试考得不错, 而对多数情况下更难的二试心存轻视, 也没能调整好自己的心态吧.</p><p>不管怎样, 接下来的OI生涯, 要更加珍惜!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了好久终于把博客修好了, 来填一些坑.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>平面树计数</title>
    <link href="http://yoursite.com/2017/count-plane-tree/"/>
    <id>http://yoursite.com/2017/count-plane-tree/</id>
    <published>2017-12-01T03:03:04.000Z</published>
    <updated>2020-07-14T12:05:04.113Z</updated>
    
    <content type="html"><![CDATA[<p>不常见的经典问题, 顺便总结一下Burnside引理吧.</p><a id="more"></a><h3 id="问题描述">问题描述</h3><blockquote><p>给定 <span class="math inline">\(N\)</span>, 求 <span class="math inline">\(N\)</span> 个点的本质不同的平面树的数量. 两棵平面树是等价的当且仅当其中一棵能够移动点的位置与另一棵重合, 且过程中仍然是一棵平面树.</p></blockquote><h3 id="做法">做法</h3><p>考虑模型转化(计算 <span class="math inline">\(N+1\)</span> 个点的答案): 取单位圆, 等距地取 <span class="math inline">\(2N\)</span> 个点, 然后将这些点两两配对连边, 满足所有连边不相交. 发现它的对偶图恰好是一棵平面树, 像这样:</p><p><img src="/img/plane-tree.png"></p><p>那么就只需要考虑本质不同的这样的配对的数量即可. 两个圆是等价的当且仅当一个圆可以通过旋转一定的角度与另一个圆重合. 而在这个圆上共有 <span class="math inline">\(2N\)</span> 个点, 就意味着有 <span class="math inline">\(2N\)</span> 个置换, 构成一个置换群.</p><p>置换群下的计数可以用到 Burnside引理 :</p><blockquote><p><span class="math display">\[ N(G, C) = \frac{1}{|G|} { \sum_{f \in G} c(f) } \]</span></p></blockquote><p>则转化为求置换下的不动点的数量:</p><ul><li><p>不存在置换的情况下, 答案为 <span class="math inline">\(C_N\)</span>, <span class="math inline">\(\mathrm{Catalan}\)</span> 数的第 <span class="math inline">\(N\)</span> 项. 即将相互匹配的位置看作左右括号, 则所有合法的括号序列都对应一个满足条件的圆.</p></li><li><p><span class="math inline">\(N\)</span> 为奇数时, 可能存在一条平分圆的对角线在置换下不变, 计算 <span class="math inline">\(\frac{N+1}{2}\)</span> 个点的答案即可.</p></li><li><p>考虑旋转置换:</p><p>为了满足旋转之后的边重合, 点 <span class="math inline">\(i\)</span> 和它的匹配点 <span class="math inline">\(p_i\)</span> 在旋转后应该仍然是相匹配的. 则环的数量一定是偶数 <span class="math inline">\(2d\)</span>, 所以环的长度可以表示为 <span class="math inline">\(\frac{2N}{2d} = \frac{N}{d}\)</span>.</p><p>假定置换的阶是 <span class="math inline">\(e\)</span>, <span class="math inline">\(e &gt; 1, e | N\)</span>, 环的数量 <span class="math inline">\(2d = \frac{2N}{e}\)</span>. 环上与 <span class="math inline">\(0\)</span> 匹配的点为 <span class="math inline">\(i\)</span>, 不难发现在这些点之间的点的方案数为 <span class="math inline">\(C_{i-1}\)</span>. 当这些点确定之后, 它们在环上依次经过的 <span class="math inline">\(e(i+1)\)</span> 个点就确定了.</p></li></ul><p>令 <span class="math inline">\(f(x)\)</span> 表示 <span class="math inline">\(\mathrm{Catalan}\)</span> 数的生成函数, 根据 <span class="math inline">\(\mathrm{Catalan}\)</span> 数的递推式, 不难得到:</p><p><span class="math display">\[ f(x) = xf^2(x) + 1 \]</span></p><p>构造 <span class="math inline">\(B_d\)</span> 表示包含 <span class="math inline">\(2d\)</span> 个环的置换下不动点的数量.</p><p><span class="math display">\[ B_d = 2\sum_{i = 0}^{d-1} C_i B_{d-i-1} \]</span></p><p>其中因子 <span class="math inline">\(2\)</span> 考虑的是 <span class="math inline">\(i &gt; 2d\)</span> 时用当前置换的逆来计算的情况.</p><p>则 <span class="math inline">\(B_d\)</span> 的生成函数 <span class="math inline">\(g(x)\)</span> 满足:</p><p><span class="math display">\[ g(x) = 2x g(x) f(x) + 1 \]</span></p><p>解得:</p><p><span class="math display">\[ g(x) = (1 - 4x) ^ {-\frac{1}{2}} \]</span></p><h3 id="问题解决">问题解决</h3><p><span class="math display">\[ p(n) = \frac{1}{2n} \left( [\mathrm{n \, is \, odd}]\binom{n}{\lfloor\frac{n}{2}\rfloor} - \binom{2n}{n-1} + \sum_{d|n}{\varphi(n/d)\binom {2d}{d}} \right)\]</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不常见的经典问题, 顺便总结一下Burnside引理吧.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Combinatorial" scheme="http://yoursite.com/tags/Combinatorial/"/>
    
      <category term="Burnside" scheme="http://yoursite.com/tags/Burnside/"/>
    
      <category term="Generating Function" scheme="http://yoursite.com/tags/Generating-Function/"/>
    
  </entry>
  
  <entry>
    <title>写在NOIP2017之后</title>
    <link href="http://yoursite.com/2017/after-noip-2017/"/>
    <id>http://yoursite.com/2017/after-noip-2017/</id>
    <published>2017-11-13T00:24:59.000Z</published>
    <updated>2020-08-17T13:12:31.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引">引</h3><blockquote><p>本来应该有另一篇博客叫做写在NOIP2017之前的, 但跑回家才意识到博客搭在机房的电脑上, 于是......</p></blockquote><a id="more"></a><h3 id="比赛过程">比赛过程</h3><h4 id="day1">Day1</h4><p>看到这个T1不送分了, 心里还是有点虚, 认真地读完了后面两题平复了一下心态. 想着既然是T1, 肯定不是送就是偷, 看着样例找了找规律, 推了个 <span class="math inline">\(a + b + (b \% a) (a &lt; b)\)</span> 的方法, 发现过不了大样例. 于是盯着大样例发呆, 突然发现了世界的奥秘. 然后写T2, 写完眼查了一下大样例, 正要关闭窗口的时候 Vimdiff 了一波, 发现自己大小写写错一大堆... T3想了想写了个不考虑零边的记忆化搜索, 发现大样例过不了 认真思考了一下发现是没有考虑到达终点又折返的情况 又想了想发现 <span class="math inline">\(-1\)</span> 挺好判的, 就加上了.</p><h4 id="day2">Day2</h4><p>到达考场时精神状态不太好, 意识模糊地打开了题目. 看完T2一直在想MST什么的, 感觉不太会做准备放弃时发现数据范围只有12, 于是秒懂了. T3没想多久推出一个平衡树的做法, 对自己代码能力过于自信没有多想就开始写, 结果调到最后一刻还是GG了.</p><h3 id="反思错误">反思错误</h3><p>感觉这次虽然题目比较奇怪, 但实际难度还是合理的, 出现了一些失误恰恰暴露出身上的一些问题.</p><ul><li>考试的时候大部分处在一种边想边写的状态, 一边写可能还要一边完善一些细节.</li><li>刷了很多Atcoder 的题目之后, 代码能力退化明显.</li><li>考场的debuff比较强.</li></ul><p>可能后面两条还稍微可以接受吧, 但是第一条的确是硬伤, 这样做简单题或者在比较清醒的时候写题可能还好, 然而一旦遇到代码实现比较复杂或者条件比较多的题目, 就会挂得很惨, 这个问题模拟赛中也出现过几次. 解决的策略其实说起来也不难, 主要就是每道题写之前把算法细节考虑基本清楚, 做到 <code>Think twice, Code once</code> 吧. 这样也不会出现某道题写了很久最后发现做法是错误的这种尴尬的情况也能够避免写一些特别复杂的做法.</p><h3 id="关于未来">关于未来</h3><p>针对这次联赛的问题和原来的一些弱点, 对接下来的一段学习做一些规划：</p><ul><li>补一些数学相关的知识（不一定OI相关）</li><li>提高一下代码能力, 复习一些不熟练的数据结构, 刷一些质量比较高的题目</li></ul><p>然后的话, 回去就要补文化了吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引&quot;&gt;引&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;本来应该有另一篇博客叫做写在NOIP2017之前的, 但跑回家才意识到博客搭在机房的电脑上, 于是......&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>CTSC2017 游戏</title>
    <link href="http://yoursite.com/2017/ctsc2017-game/"/>
    <id>http://yoursite.com/2017/ctsc2017-game/</id>
    <published>2017-08-22T12:21:17.000Z</published>
    <updated>2020-08-17T13:11:33.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="description">Description</h3><blockquote><p>有<span class="math inline">\(N\)</span> 局游戏, 除第一局游戏外每一局游戏的获胜机率均与上一局游戏的结果有关. 现在对游戏进行<span class="math inline">\(Q\)</span>次修改, 每次告诉你某一局游戏的结果或者删除之前给你的信息, 求修改后期望下获胜的场数为多少.</p></blockquote><p><span class="math inline">\(N, Q \le 2 \times 10 ^ 5\)</span></p><a id="more"></a><h3 id="solution">Solution</h3><p>首先不难发现, 某一局的游戏的胜率只与其左右的最近游戏结果相关, 所以答案可以分段计算.</p><p>考虑期望的线性性, 可以将期望胜利场数表示成每一局游戏的胜率之和. 记 <span class="math inline">\(X_i\)</span> 表示第<span class="math inline">\(i\)</span> 场游戏的状态. 所求即为 <span class="math inline">\(\sum _ {l &lt; m &lt; r} P( X _ m = 1 | X _ l, X _ r)\)</span></p><p>由贝叶斯公式: <span class="math display">\[\begin{align}P(X _ m = 1 | X _ l, X _ r) &amp;= \frac{P(X _ m = 1, X _ l, X _ r)}{P(X _ l) \cdot P(X _ r | X _ l) } \\&amp;= \frac{P(X _ l) \cdot P(X _ m = 1 | X _ l) \cdot P(X _ r | X _ l, X _ m = 1)}{P(X _ l) \cdot P(X _ r | X _ l)} \\&amp;= \frac{P(X _ m=1 | X _ l) \cdot P(X _ r | X _ l, X _ m = 1)}{P(X _ r | X _ l)} \\&amp;= \frac{P(X _ m=1 | X _ l) \cdot P(X _ r | X _ m = 1)}{P(X _ r | X _ l)} \end{align}\]</span></p><p>发现分母是常数, 于是可以合并分子. 考虑分子的意义, 大概是合法状态下当前位置为胜的概率. 每一段就可以直接用<span class="math inline">\(dp\)</span>来处理出答案, 记录某场比赛为胜/ 负的概率以及分子的期望即可. 这个复杂度是每次询问<span class="math inline">\(O(n)\)</span>的.</p><p>其实这道题要讲的已经讲完了, 最后只要用矩乘快速合并<span class="math inline">\(dp\)</span>值, 维护一下就可以了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 局游戏, 除第一局游戏外每一局游戏的获胜机率均与上一局游戏的结果有关. 现在对游戏进行&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;次修改, 每次告诉你某一局游戏的结果或者删除之前给你的信息, 求修改后期望下获胜的场数为多少.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(N, Q \le 2 \times 10 ^ 5\)&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Probability" scheme="http://yoursite.com/tags/Probability/"/>
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>两道概率题</title>
    <link href="http://yoursite.com/2017/probability-problems/"/>
    <id>http://yoursite.com/2017/probability-problems/</id>
    <published>2017-07-17T13:01:11.000Z</published>
    <updated>2018-11-29T19:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="玛里苟斯">玛里苟斯</h3><h4 id="description">Description</h4><blockquote><p>给你一个大小为N的可重集合, 求该集合子集异或和的<span class="math inline">\(K\)</span>次方的期望, 保证答案不超过<span class="math inline">\(2 ^ {64}\)</span>.</p></blockquote><p><span class="math inline">\(N \le 100000, K \le 5, A _ i \le 10 ^ 9\)</span></p><a id="more"></a><h4 id="solution">Solution</h4><p>   <span class="math inline">\(K=1\)</span> 时满足期望的线性性, 可以对每一个二进制位分开计算答案. 不难发现每一个二进制位变成 <span class="math inline">\(1\)</span> 的概率恰好为 <span class="math inline">\(\frac {1}{2}\)</span> (集合的奇数和偶数大小的子集数相同).</p><p>   <span class="math inline">\(K=2\)</span> 时要求的是期望的平方, 即: <span class="math display">\[ \sum_{i=0}^{32} \sum_{j=0}^{32} b_i b_j 2^{i+j} \]</span> 其中 <span class="math inline">\(b_i\)</span>表示期望二进制第 <span class="math inline">\(i\)</span> 位的值, 枚举两个二进制位再求一下两个位置同时取到 <span class="math inline">\(1\)</span> 的概率即可.</p><p>   <span class="math inline">\(K \ge 3\)</span>时由于答案不超过 <span class="math inline">\(2^{64}\)</span>, 所以集合内的数也不会很大, 直接用线性基处理.</p><h3 id="主旋律">主旋律</h3><h4 id="description-1">Description</h4><blockquote><p>求N个点, M条边的有向图有多少生成子图满足整个图是强联通的.</p></blockquote><p><span class="math inline">\(N \le 15, M \le N(N-1)\)</span></p><h4 id="solution-1">Solution</h4><p>   这题一眼看上去不太好做, 不妨从问题的反面来考虑. 首先一个非强联通的图缩掉<span class="math inline">\(Scc\)</span> 之后会得到若干个 <span class="math inline">\(DAG\)</span>. 如果知道<span class="math inline">\(Scc\)</span> 的划分情况, 计算<span class="math inline">\(DAG\)</span> 的数量就变成一个经典问题了:</p><p><span class="math display">\[ E(S, T) = {|\{(u, v) \in E | u \in S, v \in T)\}|} \]</span></p><p><span class="math display">\[ F(S) = \sum _ {T \subset S, T \neq \varnothing} (-1) ^ {|T| - 1}  \times 2 ^ {E(T, S-T)} F(T) \]</span></p><p>   然而感觉枚举<span class="math inline">\(Scc\)</span> 划分更不可做. 先不考虑<span class="math inline">\(Scc\)</span> 如何划分, 考虑哪一些点集构成多少个<span class="math inline">\(Scc\)</span>. 假设<span class="math inline">\(G _ K(T)\)</span>表示<span class="math inline">\(T\)</span> 集合分成<span class="math inline">\(K\)</span> 个<span class="math inline">\(Scc\)</span> 的方案数, 类似上面式子地, 有:</p><p><span class="math display">\[ F(S) = \sum _ {T \subset S, T \neq \varnothing} \sum _ {K = 1}^{|T|} (-1) ^ {K - 1} \times G _ K(T) \times 2 ^ {E(T, S-T) + E(S-T, S-T)} \]</span></p><p><span class="math display">\[ DP(S) = 2 ^ {E(S, S)} - F(S) \]</span></p><p>   实际上只需要求将某个集合分成奇数个<span class="math inline">\(Scc\)</span> 与偶数个<span class="math inline">\(Scc\)</span> 的方案数之差 <span class="math inline">\(P(S)\)</span>:</p><p><span class="math display">\[ P(S) = DP(S) + \sum _ {T \subset S, u \in T} - DP(T) \times P(S - T) \]</span></p><blockquote><p>其中 <span class="math inline">\(u \in T\)</span> 避免重复计数.</p></blockquote><p>   这样加上一些预处理的技巧可以做到 <span class="math inline">\(O(3 ^ n)\)</span>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;玛里苟斯&quot;&gt;玛里苟斯&lt;/h3&gt;
&lt;h4 id=&quot;description&quot;&gt;Description&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个大小为N的可重集合, 求该集合子集异或和的&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;次方的期望, 保证答案不超过&lt;span class=&quot;math inline&quot;&gt;\(2 ^ {64}\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(N \le 100000, K \le 5, A _ i \le 10 ^ 9\)&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Combinatorial" scheme="http://yoursite.com/tags/Combinatorial/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Probability" scheme="http://yoursite.com/tags/Probability/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder 选做</title>
    <link href="http://yoursite.com/2017/atcoder-select/"/>
    <id>http://yoursite.com/2017/atcoder-select/</id>
    <published>2017-06-29T16:00:00.000Z</published>
    <updated>2020-08-17T13:16:07.906Z</updated>
    
    <content type="html"><![CDATA[<p>其实是总结一下比赛中遇到的好题, 然后瞎做了几场 AGC 的题目练习, 感觉还比较有意思.</p><a id="more"></a><h3 id="agc">AGC</h3><h4 id="agc002-f-leftmost-ball">AGC002 F Leftmost Ball</h4><blockquote><p>给你<span class="math inline">\(N\)</span>种不同颜色的球, 每种有<span class="math inline">\(K\)</span>个, 现在你可以将球任意排列, 但最终的序列中每种颜色的第一个出现位置要被染成<span class="math inline">\(0\)</span>颜色, 求能够得到的本质不同的序列数, 对<span class="math inline">\(10^9 + 7\)</span>取模.</p></blockquote><p><span class="math inline">\(N, K \leq 2000\)</span></p><p>这题正着处理没有什么思路, 但是如果从右往左来会比较好考虑. 我们可以记<span class="math inline">\(f(i, j)\)</span>表示当前从右往左填剩下<span class="math inline">\(i\)</span>个<span class="math inline">\(0\)</span>颜色的球, 还剩下<span class="math inline">\(j\)</span>种颜色没有放的方案数. 那么每一次的决策就包括放入一个<span class="math inline">\(0\)</span>颜色的球以及添加一种颜色的<span class="math inline">\(k-1\)</span>个球:</p><p><span class="math display">\[\begin{aligned}    f(i-1, j) &amp; \leftarrow f(i, j) \mid [i &gt; j] \\    f(i, j-1) &amp; \leftarrow f(i, j) \times {n-i + (n-j) \times (k-1) + k-2 \choose k-2}\end{aligned}\]</span></p><blockquote><p>后面那个公式是可重集, 还有最后的答案要乘以<span class="math inline">\(n!\)</span>.</p></blockquote><h4 id="agc005-d-k-perm-counting">AGC005 D ~K Perm Counting</h4><blockquote><p>求长度为<span class="math inline">\(N\)</span>的排列中, 满足对任意的<span class="math inline">\(i\)</span>, 都有<span class="math inline">\(|a_i - i| \neq K\)</span>的排列数量.</p></blockquote><p><span class="math inline">\(1 \leq K &lt; N \leq 2000\)</span></p><p>考虑容斥, 计算至少有<span class="math inline">\(i\)</span>个位置不合法的方案数. 由于<span class="math inline">\(K\)</span>是确定的, 那么所有不合法的方案可以看成是完全二分图匹配中出现了一条<span class="math inline">\((i, i+k)\)</span>的边或者一条<span class="math inline">\((i, i-k)\)</span>的边.</p><p>将这样的边在画出来就是若干条交叉路径. 观察到这样的交叉路径不相交, 所以可以拆开拼成一个序列, 然后在序列上<span class="math inline">\(dp\)</span>即可.</p><h4 id="agc015-d-a-or...or-b-problem">AGC015 D A or...or B Problem</h4><blockquote><p>求在<span class="math inline">\([A, B]\)</span>中任意选出一个非空整数集合的元素位或和有多少种不同的答案.</p></blockquote><p><span class="math inline">\(1 \le A \le B \le 2^{60}\)</span></p><p>先考虑一些比较特殊的情况(以下默认<span class="math inline">\(A, B\)</span>的位数相同):</p><ul><li>当<span class="math inline">\(B\)</span>可以表示为<span class="math inline">\(2^k - 1\)</span>时, 这个位或和恰好取遍<span class="math inline">\([A, B]\)</span>之间的所有整数.</li><li>当<span class="math inline">\(A\)</span>可以表示为<span class="math inline">\(2^k\)</span>时, 这个位或和在区间<span class="math inline">\([A, A + 2^{t+1}) \mid t &lt; \log_2 A\)</span>中, 其中<span class="math inline">\(t\)</span>是最大的满足<span class="math inline">\(B\)</span>的第<span class="math inline">\(t\)</span>位为<span class="math inline">\(1\)</span>的数.</li></ul><p>那么一般情况下这些条件有什么用呢?</p><p>我们考虑找到最大的一个<span class="math inline">\(T\)</span>,使得<span class="math inline">\(B\)</span>的第<span class="math inline">\(T\)</span>位为<span class="math inline">\(1\)</span>且<span class="math inline">\(A\)</span>的第<span class="math inline">\(T\)</span>位不为<span class="math inline">\(1\)</span>, 记<span class="math inline">\(K = 2 ^ T\)</span>. 当选择的数的集合在<span class="math inline">\([A, K)\)</span>以及在<span class="math inline">\([K, B]\)</span>中的情况可以直接用上述结论.</p><p>接下来考虑同时选取两个集合中的数可能会产生的答案. 因为这时小于<span class="math inline">\(K\)</span>的部分是没有贡献的, 所以直接将<span class="math inline">\([A, K)\)</span>中的所有答案取出. 不难发现<span class="math inline">\([K, B]\)</span>中取任意个都与只使用<span class="math inline">\(K\)</span>没有区别, 那么这时候的范围是<span class="math inline">\([K+A, 2\times K-1]\)</span>, 注意减去重复贡献.</p><h4 id="agc015-f-kenus-the-ancient-greek">AGC015 F Kenus the Ancient Greek</h4><blockquote><p><span class="math inline">\(Q\)</span> 组询问, 每组询问的形式为A, B, 表示求<span class="math inline">\(x \in [1, A], y \in [1, B]\)</span>的<span class="math inline">\(g(x, y)\)</span>的最大值, 及最大值的方案数, 其中:</p></blockquote><p><span class="math display">\[g(x, y) = \begin{cases}     1, &amp; \text{y = 0} \\    g(y, x), &amp; \text{x &gt; y} \\    g(y \; mod \; x, x) + 1, &amp; \text{otherwise} \\\end{cases}\]</span></p><p><span class="math inline">\(1 \le Q \le 3 \times 10 ^ 5 \,\,, 1 \le A, B \le 10 ^ {18}\)</span></p><p><strong>以下无特殊说明, 均默认所有<span class="math inline">\(x &lt; y, A &lt; B\)</span></strong> 先考虑第一问, 如果我们由一个特定的<span class="math inline">\((x, y)\)</span>, 从小到大地构造使得<span class="math inline">\(g(x, y)\)</span>的值不断地变大, 那么如何构造使得这个值最大呢? 对于所有<span class="math inline">\((x&#39;, y&#39;)\)</span>满足<span class="math inline">\(g(x&#39;, y&#39;) = g(x, y) + 1\)</span>, 显然有:</p><p><span class="math display">\[(x&#39;, y&#39;) \in \{ (y, x + ky) \mid k \in Z^+ \} \]</span></p><p>同时, 为了使得这个过程尽可能的多次进行,我们从<span class="math inline">\((0, 1)\)</span>出发, 每次取<span class="math inline">\(k = 1\)</span>. 发现这样生成了一组<span class="math inline">\(Fibonacci\)</span>数列, 这里<span class="math inline">\(Fibonacci\)</span>数列从0开始标号. 那么第一问的答案就是求满足<span class="math inline">\(Fib_k \le A,\; Fib_{k+1} \le B\)</span>的最大的<span class="math inline">\(k\)</span>. 同时, 这样的数对是满足<span class="math inline">\(g(x, y) = k\)</span>的最小的数对. 接下来考虑统计方案数. 首先, 对于一组询问我们只需考虑其中<strong>与最优解相关</strong>的<span class="math inline">\((x, y)\)</span>. 考虑所有最优的<span class="math inline">\((x, y)\)</span>会具有的性质:</p><ul><li><span class="math inline">\(x \ge Fib_k, \; y \ge Fib_{k+1}\)</span></li><li>不存在一组<span class="math inline">\((x&#39; &lt; x, y&#39; &lt; y)\)</span>, 使得<span class="math inline">\(g(x&#39;, y&#39;) &gt; g(x, y)\)</span></li></ul><p>然而这样的<span class="math inline">\((x, y)\)</span>并不一定是最优的. 我们接着分析所有在最优解的<span class="math inline">\(g\)</span>的计算路径上的数对<span class="math inline">\((x, y)\)</span>的性质: 不难发现, 经过一次变化后得到的<span class="math inline">\((x&#39;, y&#39;)\)</span>, 一定满足:</p><ul><li><span class="math inline">\(g(x&#39;, y&#39;) = k-1\)</span></li><li><span class="math inline">\(x&#39; \ge Fib_{k-1}, y&#39; \ge Fib_{k}\)</span></li><li><span class="math inline">\(y&#39; \le Fib_{k+1} + Fib_{k-2}\)</span></li></ul><p>后面条件的解释: 若<span class="math inline">\(y&#39; &gt; Fib_{k+1} + Fib_{k-2}\)</span>, 则: <span class="math display">\[(x, y) = (y&#39; &gt; Fib_{k+1} + Fib_{k-2} &gt; Fib_{k+1}, x&#39; + py&#39; \ge x&#39; + y&#39; &gt; Fib_{k+2})\]</span> <span class="math inline">\((x, y)\)</span>不再满足上述最优性质2, 矛盾. 同时每次向下一步进行构造的时候只有<span class="math inline">\((Fib_k, Fib_{k+1})\)</span>可能取到<span class="math inline">\(p = 2\)</span>所以这样的数对个数是<span class="math inline">\(O(k)\)</span>的. 所以我们预处理所有的这样的数对, 然后用除法算下答案就好了. 复杂度<span class="math inline">\(O(\log^2{MAX} + Q\log MAX)\)</span>.</p><h3 id="arc">ARC</h3><p>ARC 的题目主要来源是打过的几场比赛, 暂时不多.</p><h4 id="arc074-e-rgb-sequence">ARC074 E RGB Sequence</h4><blockquote><p>给你一个长度为<span class="math inline">\(N\)</span>的序列和<span class="math inline">\(M\)</span>组约束条件, 每组条件形如<span class="math inline">\(L_i, R_i, X_i\)</span>, 表示序列上的<span class="math inline">\([L_i, R_i]\)</span>中恰好有<span class="math inline">\(X_i\)</span>种颜色, 现在要你用三种颜色给这个序列染色, 求满足所有约束的方案数.</p></blockquote><p><span class="math inline">\(1 \le N, M \le 300\)</span></p><p><span class="math inline">\(dp\)</span>的思路应该比较显然, 然而普通的状态表示不太好处理. 我们记<span class="math inline">\(dp_{r, g, b}\)</span>表示三种颜色的球最后一次出现的位置分别是<span class="math inline">\(r, g, b\)</span>时的方案数.</p><p>然后考虑状态的合法性, 可以把条件存在<span class="math inline">\(R_i\)</span>的位置. 当选择一个状态时, 考虑这个状态的最末位的所有约束即可.</p><h4 id="arc077-f-ss">ARC077 F SS</h4><blockquote><p>定义一个字符串为偶的, 当且仅当这个字符串能够被分成两个完全相同的字符串.</p></blockquote><p>定义函数<span class="math inline">\(f(s)\)</span>, 其中<span class="math inline">\(s, f(s)\)</span>均是字符串,<span class="math inline">\(f(s)\)</span>为在字符串<span class="math inline">\(s\)</span>后添加非空的字符满足新串为偶且长度最小的串. 现在给你串<span class="math inline">\(s\)</span>(初始为偶的), 求<span class="math inline">\(f^{10^{100}}(s)[L, R]\)</span>中各个字母的出现次数. <span class="math inline">\(1 \le |S| \le 2\times 10^5\)</span> <span class="math inline">\(1 \le L \le R \le 10^{18}\)</span></p><p>首先对于一个给定的<span class="math inline">\(s\)</span>, 其<span class="math inline">\(f(s)\)</span>必定唯一. 考虑每次最少加一个字符,<span class="math inline">\(f^{10^{100}}(s)\)</span>就等价于一个长度无穷的字符串. 这个答案的形式显然可以前缀和, 又因为<span class="math inline">\(s\)</span>在变化过程中始终是偶的, 实际上我们只需要关注左半部分的字符.</p><p>我们从最简单的一次操作来考虑. 记初始的字符串<span class="math inline">\(s\)</span>为<span class="math inline">\(SS\)</span>, 记一次变化之后左边的部分为<span class="math inline">\(ST\)</span>, 那么得到的新串就是<span class="math inline">\(STST\)</span>. 要使得加的字符长度最小, 就要在<span class="math inline">\(S\)</span>中找到最长前后缀匹配长度, 这时<span class="math inline">\(T\)</span>就是<span class="math inline">\(S\)</span>去掉最长匹配后缀所得.</p><p>我们发现, 每次操作都等价于找到前后缀匹配最大长度(当然要小于<span class="math inline">\(|S|\)</span>), 然后将剩下部分的前缀<span class="math inline">\(T\)</span>添加到<span class="math inline">\(S\)</span>的末尾.</p><ul><li>当<span class="math inline">\(|T| \mid |S|\)</span>时,<span class="math inline">\(|S|\)</span>有长为<span class="math inline">\(|T|\)</span>的最小周期, 每次加入的<span class="math inline">\(|T|\)</span>相同.</li><li>当<span class="math inline">\(|T| \nmid|S|\)</span>时, 我们<del>通过打表</del>发现, 这样的<span class="math inline">\(T\)</span>是在有规律地变化的, 因为每次加入<span class="math inline">\(T\)</span>之后的串前后缀最长匹配一定是<span class="math inline">\(|T|\)</span>, 否则的话, 上一步中最长匹配的性质就不一定会满足.</li></ul><p>然后我们得到了一个<span class="math inline">\(Fibonacci\)</span>数列? 直接暴力算就好了... 实际上第一种情况也可以直接算, 因为整个序列都是<span class="math inline">\(T\)</span>的若干次重复得到的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实是总结一下比赛中遇到的好题, 然后瞎做了几场 AGC 的题目练习, 感觉还比较有意思.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Combinatorial" scheme="http://yoursite.com/tags/Combinatorial/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Summary" scheme="http://yoursite.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Div2 418E</title>
    <link href="http://yoursite.com/2017/cf-418e/"/>
    <id>http://yoursite.com/2017/cf-418e/</id>
    <published>2017-06-12T12:56:07.000Z</published>
    <updated>2018-11-29T19:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="description">Description</h3><blockquote><p>求满足如下条件的 <span class="math inline">\(N\)</span> 个点的简单无向图的个数对 $ 1e9 + 7 $ 取模的结果： - 每个点的度数均为 <span class="math inline">\(2\)</span> 或 <span class="math inline">\(3\)</span> - 从一号点到任何一个点的最短路唯一并且随着点标号上升而不降.</p></blockquote><p>(两个图不同当且仅当边的集合不同). <span class="math inline">\(N &lt;= 50\)</span></p><a id="more"></a><h3 id="solution">Solution</h3><p>我们可以记: - <span class="math inline">\(f_{i, j}\)</span> 表示考虑完前 <span class="math inline">\(i\)</span> 个点, 最后一层恰好有 <span class="math inline">\(j\)</span> 个点, 且最后一层之前的点度数已经满足条件时的方案数. - <span class="math inline">\(g_{i, j, k}\)</span> 表示当前层有 <span class="math inline">\(i\)</span> 个点, 上一层剩下来 <span class="math inline">\(j\)</span> 个度为 <span class="math inline">\(2\)</span> 的点, <span class="math inline">\(k\)</span> 个度为 <span class="math inline">\(3\)</span> 的点时连边的方案数.</p><p>那么容易得到<span class="math inline">\(f_{i, j} = \sum_{k} f_{i-j, k} \times g_{j, c0, c1}\)</span>, 其中<span class="math inline">\(c0\,,c1\)</span>表示最后一层 <span class="math inline">\(k\)</span> 个点中度为 <span class="math inline">\(2\)</span> 的点和度为 <span class="math inline">\(3\)</span> 的点的个数.</p><p>对于 <span class="math inline">\(g\)</span>, 不难得到:</p><p><span class="math display">\[ g_{i, j, k} = \begin{cases}     1 &amp; i = 0, j = 0, k = 0 \\    \sum_{l=2}^{k-1} \frac{l!}{2} {k-1 \choose l} g_{i, j, k-l-1} &amp; i = 0, j = 0, k &gt; 0 \\    (j-1) \cdot g_{i, j-2, k} + k \cdot g_{i, j, k-1} &amp; i = 0, j &gt; 0 \\    j \cdot g_{i-1, j-1, k} + k \cdot g_{i-1, j+1, k-1} &amp; i &gt; 0\end{cases}\]</span></p><h3 id="hint">Hint</h3><p>注意在第二个递推式中 <span class="math inline">\(l\)</span> 从 <span class="math inline">\(2\)</span> 开始枚举, 因为不能有重边, 所以不存在大小为 <span class="math inline">\(2\)</span> 的环.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;求满足如下条件的 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个点的简单无向图的个数对 $ 1e9 + 7 $ 取模的结果： - 每个点的度数均为 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt; - 从一号点到任何一个点的最短路唯一并且随着点标号上升而不降.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(两个图不同当且仅当边的集合不同). &lt;span class=&quot;math inline&quot;&gt;\(N &amp;lt;= 50\)&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Combinatorial" scheme="http://yoursite.com/tags/Combinatorial/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2017 树状数组</title>
    <link href="http://yoursite.com/2017/zjoi2017-bit/"/>
    <id>http://yoursite.com/2017/zjoi2017-bit/</id>
    <published>2017-06-12T12:04:19.000Z</published>
    <updated>2018-11-29T19:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="description">Description</h3><blockquote><p>给你一个长度为 <span class="math inline">\(N\)</span> 的序列以及 <span class="math inline">\(M\)</span> 次操作, 每次等概率地修改 <span class="math inline">\([L_i, R_i]\)</span> 区间中一个值的奇偶性, 或者对于询问<span class="math inline">\([L_i,R_i]\)</span>区间中的和的奇偶性, 判断给定的一种错误算法输出正确答案的概率是多少 $ N, M &lt;= 10^5 $</p></blockquote><a id="more"></a><h3 id="solution">Solution</h3><p>考虑这个错误算法, 由于可以把 $ + lowbit $ 和 $ - lowbit $ 都看成在一棵树上向父亲节点跳, 根据这个性质可以知道错误算法求了一个后缀和, 所以当且仅当对于询问区间 <span class="math inline">\([L_i, R_i]\)</span>, 满足 $ a[L_i-1] = a[R_i] $ 时它会输出正确答案</p><p>那么我们得到了一个 $ O(nm) $ 的暴力算法, 即每一个询问都暴力扫之前的所有修改计算概率即可.</p><p>然而这样还不能通过所有数据, 考虑将区间 <span class="math inline">\([L_i, R_i]\)</span> 表示成二维平面上的一个点 $ (L_i, R_i)$.</p><p>然后用一个二维线段树去维护每个点代表的两个端点的值不相等的概率.显然地, 这个概率是可以很方便的合并的. 这样对于每次修改<span class="math inline">\([L_i, R_i]\)</span>的操作, 相当于: - 将 $ x , y $ 中的点 <span class="math inline">\((x, y)\)</span> 与 $  $ 合并. - 将 $ x , y (R_i, N] $ 以及 $ x $ 与 $  $ 合并.</p><h3 id="hint">Hint</h3><p>注意到对于 $ L_i = 1 $ 的情况, $ Find(0) $ 直接返回了 <span class="math inline">\(0\)</span> 而非 <span class="math inline">\(0\)</span> 的后缀和 这个时候就要特判一下了, 注意到每次不管如何修改, 最终的正确答案是 <span class="math inline">\(R_i\)</span> 的前缀和, 而题中所给的方法输出的答案是 <span class="math inline">\(R_i\)</span> 的后缀和.</p><ul><li>当前修改次数为偶数, 则当且仅当 <span class="math inline">\(R_i = 0\)</span> 前后缀和相同, 相当于查询 <span class="math inline">\(a[R_i] = 0\)</span> 的概率.</li><li>当前修改次数为奇数, 则当且仅当 <span class="math inline">\(R_i = 1\)</span> 前后缀和相同, 相当于查询 <span class="math inline">\(a[R_i] = 1\)</span> 的概率.</li></ul><p>因为 <span class="math inline">\(a[0]\)</span> 不可能被修改, 所以上述问题也可以转化为查询 <span class="math inline">\([L_i, R_i]\)</span> 相等概率.</p><h3 id="code">Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fst first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> snd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar getchar_unlocked</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chkmax</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chkmin</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> oo = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span>( ;!<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; <span class="built_in">isdigit</span>(ch); ch = getchar()) n = n * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">return</span> n * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * (<span class="number">1L</span>L - b + mod) % mod + b * (<span class="number">1L</span>L - a + mod) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M, prob;</span><br><span class="line"><span class="keyword">namespace</span> Seg_Tree &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SZ_X = (maxn &lt;&lt; <span class="number">2</span>) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SZ_Y = (maxn * <span class="number">400</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rt[SZ_X];</span><br><span class="line">    <span class="keyword">int</span> val[SZ_Y];</span><br><span class="line">    <span class="keyword">int</span> lc[SZ_Y], rc[SZ_Y], cnt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC (u &lt;&lt; 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC (LC | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add_Y</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u = ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            val[u] = merge(val[u], prob);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) Add_Y(lc[u], l, mid, x, y);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) Add_Y(rc[u], mid+<span class="number">1</span>, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add_X</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            Add_Y(rt[u], <span class="number">0</span>, N, x0, y0);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) Add_X(LC, l, mid, x, y, x0, y0);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) Add_X(RC, mid+<span class="number">1</span>, r, x, y, x0, y0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query_Y</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> val[u];</span><br><span class="line">        <span class="keyword">return</span> merge(val[u], </span><br><span class="line">                x &lt;= mid ? query_Y(lc[u], l, mid, x) : query_Y(rc[u], mid+<span class="number">1</span>, r, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query_X</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> x0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> query_Y(rt[u], <span class="number">0</span>, N, x0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(query_Y(rt[u], <span class="number">0</span>, N, x0), </span><br><span class="line">                x &lt;= mid ? query_X(LC, l, mid, x, x0) : query_X(RC, mid+<span class="number">1</span>, r, x, x0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpm</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">1</span>) </span><br><span class="line">            res = <span class="number">1L</span>L * res * base % mod;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = read(); M = read();</span><br><span class="line">    <span class="keyword">while</span>(M--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> ty, l, r;</span><br><span class="line">        ty = read(); l = read(); r = read();</span><br><span class="line">        <span class="keyword">if</span>(ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">static</span> LL tmp; </span><br><span class="line">            tmp = fpm(r-l+<span class="number">1</span>, mod<span class="number">-2</span>);</span><br><span class="line">            prob = <span class="number">2</span>*tmp; Seg_Tree::Add_X(<span class="number">1</span>, <span class="number">0</span>, N, l, r, l, r); </span><br><span class="line">            prob = tmp; Seg_Tree::Add_X(<span class="number">1</span>, <span class="number">0</span>, N, l, r, r+<span class="number">1</span>, N);</span><br><span class="line">            prob = tmp; Seg_Tree::Add_X(<span class="number">1</span>, <span class="number">0</span>, N, <span class="number">0</span>, l<span class="number">-1</span>, l, r);</span><br><span class="line">            ++ tot;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> ans;</span><br><span class="line">            ans = (<span class="number">1</span>-Seg_Tree::query_X(<span class="number">1</span>, <span class="number">0</span>, N, l<span class="number">-1</span>, r)+mod) % mod;</span><br><span class="line">            <span class="keyword">if</span>(!(l<span class="number">-1</span>) &amp;&amp; (tot &amp; <span class="number">1</span>))</span><br><span class="line">                ans = (<span class="number">1</span>-ans+mod) % mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"data.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"ans.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个长度为 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 的序列以及 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 次操作, 每次等概率地修改 &lt;span class=&quot;math inline&quot;&gt;\([L_i, R_i]\)&lt;/span&gt; 区间中一个值的奇偶性, 或者对于询问&lt;span class=&quot;math inline&quot;&gt;\([L_i,R_i]\)&lt;/span&gt;区间中的和的奇偶性, 判断给定的一种错误算法输出正确答案的概率是多少 $ N, M &amp;lt;= 10^5 $&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>NOI2016 网格</title>
    <link href="http://yoursite.com/2017/noi2016-grid/"/>
    <id>http://yoursite.com/2017/noi2016-grid/</id>
    <published>2017-06-10T06:36:06.000Z</published>
    <updated>2018-11-29T19:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="description">Description</h3><blockquote><p>给出一个 $ N M $ 的网格图和图上的 $ C $ 个障碍物, 求最少删去多少个点可使得原图空格不四连通. $ N, M &lt;= 10 ^ 9, C &lt;= 10 ^ 5 $</p></blockquote><a id="more"></a><h3 id="solution">Solution</h3><p>我们可以发现, 可能的答案只有 $ { -1, 0, 1, 2 } $ 几种.</p><p>考虑一些简单的情况: 答案等于 $ -1 $ 时, 点数小于 <span class="math inline">\(2\)</span> 或者恰好有两个相邻的点. 答案为 $ 0 $ 时, 显然原图不连通.</p><p>那么就只需知道答案是否为 $ 1 $, 发现答案等于 $ 1 $ 当且仅当原图存在割点, 暴力的话不难做到 $ O(n * m) $.</p><p>将到达每个障碍的曼哈顿距离不超过 <span class="math inline">\(2\)</span> 的空格给提出来, 然后在这些点中找出一个割点, 满足到达最近的障碍的距离不超过 <span class="math inline">\(1\)</span>.<br>这样的点就一定是原图中的割点.</p><h3 id="code">Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fst first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> snd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmax</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmin</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2.5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> oo = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T n = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span>( ;!<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; <span class="built_in">isdigit</span>(ch); ch = getchar()) n = n * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">return</span> n * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash_Map</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1666667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> st[mod], nxt[maxn], X[maxn], Y[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="number">233L</span>L*x + (y^<span class="number">888</span>))%mod + mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = idx(x, y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = st[u]; i; i = nxt[i]) </span><br><span class="line">            <span class="keyword">if</span>(X[i] == x &amp;&amp; Y[i] == y) </span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = idx(x, y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = st[u]; i; i = nxt[i]) </span><br><span class="line">            <span class="keyword">if</span>(X[i] == x &amp;&amp; Y[i] == y) </span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">        ++ cnt;</span><br><span class="line">        X[cnt] = x, Y[cnt] = y;</span><br><span class="line">        nxt[cnt] = st[u]; st[u] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;HM;</span><br><span class="line"></span><br><span class="line">LL n, m, c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[maxn], nxt[maxn &lt;&lt; <span class="number">3</span>], to[maxn &lt;&lt; <span class="number">3</span>], ecnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    to[++ecnt] = y; nxt[ecnt] = st[x]; st[x] = ecnt;</span><br><span class="line">    to[++ecnt] = x; nxt[ecnt] = st[y]; st[y] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> mark[maxn], now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ecnt = <span class="number">1</span>;</span><br><span class="line">    HM.clear();</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flood_fill</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    mark[u] = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st[u], v; i; i = nxt[i]) <span class="keyword">if</span>(mark[v = to[i]] != now) </span><br><span class="line">        res += flood_fill(v);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area_count</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="keyword">return</span> ++ now, flood_fill(s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n*m-c &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = area_count(c + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n*m == <span class="number">2</span> || (res == <span class="number">2</span> &amp;&amp; n*m-c == <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], dfs_clock = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">bool</span> f = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st[u], v; i; i = nxt[i]) <span class="keyword">if</span>((v = to[i]) ^ fa) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(v, u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(vis[u] == <span class="number">1</span> &amp;&amp; (low[v] &gt; dfn[u] || (!f &amp;&amp; low[v] == dfn[u]))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chkmin(low[u], low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> chkmin(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, dfs_clock = <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c+<span class="number">1</span>; i &lt;= HM.cnt; i++) <span class="keyword">if</span>(!dfn[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(i, <span class="number">0</span>, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x(i) HM.X[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y(i) HM.Y[i]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char ch[1000][1000];</span></span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn], idx[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(idx, <span class="number">0</span>, <span class="keyword">sizeof</span> idx);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) HM.insert(X[i], Y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= c; v++) <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> q[maxn];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ecnt = <span class="number">1</span>;</span><br><span class="line">        vis[q[tail++] = v] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = q[head++];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x(h) + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = y(h) + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m) &#123;</span><br><span class="line">                    <span class="keyword">int</span> Nxt = HM.insert(nx, ny);</span><br><span class="line"></span><br><span class="line">                    st[Nxt] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Nxt &lt;= c) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!vis[Nxt]) &#123;</span><br><span class="line">                            vis[Nxt] = <span class="number">3</span>;</span><br><span class="line">                            q[tail++] = Nxt;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx[Nxt] != v) &#123;</span><br><span class="line">                        idx[Nxt] = v, V.pb(Nxt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(V.size()); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = V[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x(u) + dx[j];</span><br><span class="line">                <span class="keyword">int</span> ny = y(u) + dy[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m) &#123;</span><br><span class="line">                    <span class="keyword">int</span> Nxt = HM.find(nx, ny);</span><br><span class="line">                    <span class="keyword">if</span>(idx[Nxt] == v) addedge(u, Nxt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(V.size() &amp;&amp; area_count(V[<span class="number">0</span>]) != <span class="keyword">int</span>(V.size()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) </span><br><span class="line">        HM.insert(X[i], Y[i]), vis[i] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = X[i] + dx[j];</span><br><span class="line">            <span class="keyword">int</span> ny = Y[i] + dy[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m) &#123;</span><br><span class="line">                <span class="keyword">int</span> Nxt = HM.insert(nx, ny);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!vis[Nxt]) &#123;</span><br><span class="line">                    vis[Nxt] = <span class="number">1</span>;</span><br><span class="line">                    q[tail++] = Nxt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lim = tail;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x(q[i]) + dx[j];</span><br><span class="line">            <span class="keyword">int</span> ny = y(q[i]) + dy[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m) &#123;</span><br><span class="line">                <span class="keyword">int</span> Nxt = HM.insert(nx, ny);</span><br><span class="line">                <span class="keyword">if</span>(!vis[Nxt]) &#123;</span><br><span class="line">                    vis[Nxt] = <span class="number">2</span>;</span><br><span class="line">                    q[tail++] = Nxt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tail; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x(q[i]) + dx[j];</span><br><span class="line">            <span class="keyword">int</span> ny = y(q[i]) + dy[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m) &#123;</span><br><span class="line">                <span class="keyword">int</span> Nxt = HM.find(nx, ny);</span><br><span class="line">                <span class="keyword">if</span>(Nxt &gt; c) addedge(q[i], Nxt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        Y[++c] = <span class="number">0</span>; Y[++c] = m+<span class="number">1</span>; sort(Y+<span class="number">1</span>, Y+c+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= c; i++) <span class="keyword">if</span>(Y[i] - Y[i<span class="number">-1</span>] &gt; <span class="number">1</span>) ++ res;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        X[++c] = <span class="number">0</span>; X[++c] = n+<span class="number">1</span>; sort(X+<span class="number">1</span>, X+c+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= c; i++) <span class="keyword">if</span>(X[i] - X[i<span class="number">-1</span>] &gt; <span class="number">1</span>) ++ res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt;= <span class="number">2</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"data.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"ans.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> T = read&lt;<span class="keyword">int</span>&gt;(); T--; ) &#123;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        n = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        m = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        c = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) &#123;</span><br><span class="line">            X[i] = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            Y[i] = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(chk0()) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span>((ans = chk()) != <span class="number">-2</span>) &#123; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(min(n, m) == <span class="number">1</span>) &#123; ans = spe(); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = chk1() ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">0</span>) ans = min(n, m) == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个 $ N M $ 的网格图和图上的 $ C $ 个障碍物, 求最少删去多少个点可使得原图空格不四连通. $ N, M &amp;lt;= 10 ^ 9, C &amp;lt;= 10 ^ 5 $&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Graph Theory" scheme="http://yoursite.com/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 553E Kyoya and Train</title>
    <link href="http://yoursite.com/2017/cf-553e/"/>
    <id>http://yoursite.com/2017/cf-553e/</id>
    <published>2017-05-03T13:21:27.000Z</published>
    <updated>2020-07-14T12:09:41.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="description">Description</h3><blockquote><p>给定 <span class="math inline">\(N\)</span> 个点, <span class="math inline">\(M\)</span> 条边的有向图.</p></blockquote><p>每条边有花费: 通过第 <span class="math inline">\(i\)</span> 条边的时间有 $ P _ {i1} $ 的概率为 <span class="math inline">\(1\)</span>, <span class="math inline">\(P _ {i2}\)</span> 的概率为 <span class="math inline">\(2\)</span>... 如果总用时超过 <span class="math inline">\(T\)</span> 则会被罚钱 <span class="math inline">\(X\)</span> 元, 求从 <span class="math inline">\(1\)</span> 号点到 <span class="math inline">\(n\)</span> 号点的最小期望花费. $ N , M , T  $</p><h3 id="solution">Solution</h3><p>考虑暴力DP, 记状态 $ dp _ {i, t} $ 表示到达 <span class="math inline">\(i\)</span> 号点, 且经过的时间为 <span class="math inline">\(t\)</span> 的最小期望花费, 转移十分显然. 同时因为状态之间按照时间构成一个拓扑图, 所以转移不存在环.</p><a id="more"></a><p>可以记 <span class="math inline">\(S_{e, t}\)</span> 表示边 <span class="math inline">\(e\)</span> 在时刻 <span class="math inline">\(t\)</span> 之后后继状态的最小期望花费. 则可以用下面这个式子计算 <span class="math inline">\(dp _ {e, t}\)</span>:</p><p><span class="math display">\[d_{i, t} = \min \left\{ S_{e, t} + cost_e \right\}\]</span></p><p><span class="math inline">\(e\)</span> 是 <span class="math inline">\(i\)</span> 的出边.</p><p>接下来考虑如何计算 <span class="math inline">\(S(e,t)\)</span>, 利用定义:</p><p><span class="math display">\[S_{e, t} = \sum_{i = 1}^{T} dp_{to_e, t+i} * P_{ei}\]</span></p><p>这样变成卷积形式, 分治 <span class="math inline">\(FFT\)</span> 即可.</p><h3 id="code">Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> oo = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmax</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmin</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fst first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> snd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">":"</span> &lt;&lt; (x) &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i, a, b) for(int i = (a), i##end = (b); i &lt; i##end; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DREP(i, a, b) for(int i = (a)-1, i##bgn = (b); i &gt;= i##bgn; --i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T n = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span>( ;!<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; <span class="built_in">isdigit</span>(ch); ch = getchar()) n = n * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">return</span> n * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>): real(r), imag(i) &#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real + rhs.real, imag + rhs.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real - rhs.real, imag - rhs.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real*rhs.real - imag*rhs.imag, real*rhs.imag + imag*rhs.real);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span>&amp; div) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real / div, imag / div);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Complex *x, <span class="keyword">int</span> N, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) swap(x[i], x[rev[i]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= N; l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(<span class="number">2</span>*PI*t/l), <span class="built_in">sin</span>(<span class="number">2</span>*PI*t/l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += l) &#123;</span><br><span class="line">            Complex w = Complex(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (l &gt;&gt; <span class="number">1</span>); j++, w = w * wn) &#123;</span><br><span class="line">                Complex L = x[i + j];</span><br><span class="line">                Complex R = x[i + j + (l &gt;&gt; <span class="number">1</span>)] * w;</span><br><span class="line">                x[i + j] = L + R;</span><br><span class="line">                x[i + j + (l &gt;&gt; <span class="number">1</span>)] = L - R;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!~t) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) x[i] = x[i] / N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, t, x;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">    <span class="keyword">double</span> p[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        u = read&lt;<span class="keyword">int</span>&gt;(), v = read&lt;<span class="keyword">int</span>&gt;(), c = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        chkmin(dis[u][v], c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) p[i] = <span class="keyword">double</span>(read&lt;<span class="keyword">int</span>&gt;()) / <span class="number">100000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[N];</span><br><span class="line"></span><br><span class="line">Complex A[maxn], B[maxn];</span><br><span class="line"><span class="keyword">double</span> S[N][maxn], f[N][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> base, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[k].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(base = <span class="number">1</span>, len = <span class="number">0</span>; base &lt;= <span class="number">2</span>*r-l-mid+<span class="number">1</span>; base &lt;&lt;= <span class="number">1</span>) ++ len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (len<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) A[i] = B[i] = Complex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r-mid; i++) A[i] = Complex(f[v][r-i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r-l; i++) B[i<span class="number">-1</span>] = Complex(E[k].p[i], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        DFT(A, base, <span class="number">1</span>); DFT(B, base, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) A[i] = A[i] * B[i];</span><br><span class="line">        DFT(A, base, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++) S[k][i] += A[r-i<span class="number">-1</span>].real;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq_solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">            chkmin(f[E[i].u][l], S[i][l] + E[i].c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    cdq_solve(mid+<span class="number">1</span>, r);</span><br><span class="line">    calc(l, r, mid);</span><br><span class="line">    cdq_solve(l, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"data.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"ans.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dis, oo, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    n = read&lt;<span class="keyword">int</span>&gt;(), m = read&lt;<span class="keyword">int</span>&gt;(), t = read&lt;<span class="keyword">int</span>&gt;(), x = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) E[i].input();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">                chkmin(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> T = <span class="number">0</span>; T &lt;= t; T++) f[i][T] = (i == n) ? <span class="number">0</span> : oo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> T = t+<span class="number">1</span>; T &lt;= <span class="number">2</span>*t; T++) f[i][T] = dis[i][n] + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calc(<span class="number">1</span>, t*<span class="number">2</span>, t);</span><br><span class="line">    cdq_solve(<span class="number">0</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个点, &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 条边的有向图.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每条边有花费: 通过第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 条边的时间有 $ P _ {i1} $ 的概率为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(P _ {i2}\)&lt;/span&gt; 的概率为 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;... 如果总用时超过 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 则会被罚钱 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 元, 求从 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 号点到 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 号点的最小期望花费. $ N , M , T  $&lt;/p&gt;
&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;
&lt;p&gt;考虑暴力DP, 记状态 $ dp _ {i, t} $ 表示到达 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 号点, 且经过的时间为 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的最小期望花费, 转移十分显然. 同时因为状态之间按照时间构成一个拓扑图, 所以转移不存在环.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Probability" scheme="http://yoursite.com/tags/Probability/"/>
    
      <category term="Generating Function" scheme="http://yoursite.com/tags/Generating-Function/"/>
    
  </entry>
  
</feed>
